<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Angular A2Z</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <main class="container">
    <section>
      <h2>Set Up</h2>  
      <pre>
        npm install -g @angular/cli@latest
        ng new app-name
        cd app-name
        ng serve
      </pre> 
    </section>
    <section>
      <h2>Adding Module</h2>
      <p>If we want to add any module in our application, we have to include it in our app.module.ts file.</p>
      <pre>
        import { module-name } from 'source-name'
        @NgModule({
          ......,
          imports:[
            ......,
            module-name
          ],
          ....
        })
      </pre>
    </section>
    <section>
      <h2>Kick Start</h2>
      <p>In 'main.ts' file we define which module to start first.</p>
      <pre>
        platformBrowserDynamic().bootstrapModule(AppModule)
      </pre>
      <p>In 'app.module.ts' file we tell which component is the root compoenent.</p>
      <pre>
        @NgModule({
          ......,
          bootstrap:[AppComponent],
          ....
        })
      </pre>
      <p>In 'app.component.ts' file we define component selector tag.</p>
      <p>Angular serves 'index.html' file which contains app component tag.</p>
    </section>
    <section>
      <h2>Component</h2>
      <p>Component selector is used to tell Angular to consider a class as a component.</p>
      <p>It contains all necessary information regarding that component.</p>
      <pre>
        @Component({
          selector: 'tag-name',  ##used in html code to represent this component
          templateUrl: 'html-file-path',
          styleUrls: [...list of stylesheet files]
        })
      </pre>
      <p>TemplateUrl or template is a required attribute. But we can skip selector, styleUrls etc.</p>
      <p>To Register a component, add the component class name inside declaration array of NgModule decorator in app.module.ts file.</p>
      <p>Component creation shortcut : <span>ng g c 'component-name'</span></p>
      <p>Three ways to use component selector :</p>
      <p>1. We declare selector: 'tag-name' and use it as, <span>&lt;tag-name&gt;&lt;/tag-name&gt;</span></p>
      <p>2. We declare selector: '[tag-name]' and use it as attribute, <span>&lt;div tag-name&gt;&lt;/div&gt;</span></p>
      <p>3. We declare selector: '.tag-name' and use it as class, <span>&lt;div class="tag-name"&gt;&lt;/div&gt;</span></p>
    </section>
    <section>
      <h2>String Interpolation</h2>
      <p>String interpolation: <span>{{data}}</span></p>
      <p>Here data can be anything as long as it generates a string.</p>
      <p>So data can be variable from .ts file, or function or expression.</p>
      <p>But we cannot write multi line expression here.</p>
      <p>We can not use if else block; but we can use ternary expression.</p>
    </section>
    <section>
      <h2>Property Binding</h2>
      <p>Property binding: <span>[property]="data"</span></p>
      <p>Here data can be anything as long as it generates a proper value for that property.</p>
      <p>We can sometimes replace string interpolation with property binding, for example:</p>
      <p>In .ts file,</p>
      <pre>
        title = 'Hello World!';
      </pre>
      <p>In .html file,</p>
      <pre>
        &lt;p&gt;{{title}}&lt;/p&gt;
        &lt;p [innerText]="title"&gt;&lt;/p&gt;
      </pre>
    </section>
    <section>
      <h2>Event Binding</h2>
      <p>Event binding: <span>(event)="expression"</span></p>
      <pre>
        (click)="addNewUser()"
        (input)="updateUsername($event)"  ## Here $event refers to the value that input event emits
      </pre>
    </section>
    <section>
      <h2>Two way Binding</h2>
      <p>Two way binding: <span>[(ngModel)]="data"</span></p>
      <pre>
        username = "";                              ## In .ts file
        &lt;input type="text" [(ngModel)]="username"&gt;  ## In .html file
      </pre>
      <p>Now if input changes, value of username will change too. Also if value of username changes, value of input field will change too.</p>
    </section>
    <section>
      <h2>Directive</h2>
      <p>Directives are instructions in the DOM.</p>
      <p>Components are kind of such instructions in the DOM.</p>
      <p>Once we place the selector of our component somewhere in our templates, we're in
        structing Angular to add the content of our component template and the business logic in our TypeScript code in this place where we use the selector.
      </p>
      <p>Indeed components are directives but directives with a template, there are also directives without a template.</p>
      <p>For example, <span>*ngIf</span> is a structural directive that changes the structure of the dom.</p>
      <p><span>ngStyle</span>, <span>ngClass</span> are attribute directives, without a * before. They just modify element.</p>
      <p>Some directive take static value like true or false whereas some take js object.</p>
    </section>
    <section>
      <h2>ngStyle</h2>
      <pre>
        &lt;p [ngStyle]="{backgroundColor: getColor()}"&gt;Hello World&lt;/p&gt;
        &lt;p [ngStyle]="{'background-color': status == true ? 'green' : 'red'}"&gt;Hello World&lt;/p&gt;
      </pre>
      <p>So it works like a attribute, thus we can use property binding on it.</p>
      <p>It allows us to dynamically add or remove css styles.</p>
      <p>It takes an object; key value pair, where key is a css property, value can be anything.</p>
    </section>
    <section>
      <h2>ngClass</h2>
      <pre>
        &lt;p [ngClass]="{'active': getStatus()}"&gt;Hello World&lt;/p&gt;
      </pre>
      <p>So it works like a attribute, thus we can use property binding on it.</p>
      <p>It allows us to dynamically add or remove css class.</p>
      <p>It takes an object; key value pair, where key is a class name, value can be anything that returns true or false.</p>
    </section>
    <section>
      <h2>If Else</h2>
      <pre>
        &lt;p *ngIf="isVisible; else elseblock">You are visible now&lt;/p&gt;
        &lt;ng-template #elseblock&gt;
          &lt;p&gt;You are invisible&lt;/p&gt;
        &lt;/ng-template&gt;
      </pre>
    </section>
    <section>
      <h2>For Loop</h2>
      <pre>
        &lt;p *ngFor="let item of items, let i = index"&gt;{{i}}. Hi {{item}}&lt;/p&gt;
      </pre>
    </section>
    <section>
      <h2>Switch Case</h2>
      <pre>
        &lt;div [ngSwitch]="value"&gt;
          &lt;p *ngSwitchCase="1"&gt;Value is 1&lt;/p&gt;
          &lt;p *ngSwitchCase="2"&gt;Value is 2&lt;/p&gt;
          &lt;p *ngSwitchCase="3"&gt;Value is 3&lt;/p&gt;
          &lt;p *ngSwitchDefault&gt;Value is default&lt;/p&gt;
        &lt;/div&gt;
      </pre>
    </section>
    <section>
      <h2>Passing data to child component</h2>
      <p>We will use property binding.</p>
      <p>We will use <span>Input()</span> decorator.</p>
      <p>In parent.ts file,</p>
      <pre>
        serverElements = [{os:'linux', version:'ubuntu'}, {os:'windows', version:'10'}]
      </pre>
      <p>In parent.html file,</p>
      <pre>
        &lt;app-child *ngFor="se of serverElements" [server]="se"&gt;&lt;/app-child&gt;
      </pre>
      <p>In child.ts file,</p>
      <pre>
        @Input() server : {os:string, version:string};
      </pre>
      <p>In child.html file,</p>
      <pre>
        &lt;p&gt;{{server.os}} {{server.version}}&lt;/p&gt;
      </pre>
      <p>We can bind throuh alias, instead of using direct property name.</p>
      <pre>
        @Input("alias name"), then in parent html file ["alias name"]="data".
      </pre>
    </section>
    <section>
      <h2>Listening event from child component</h2>
      <p>We will use event binding.</p>
      <p>We will use <span>EventEmitter&lt;&gt;()</span> class and <span>Output()</span> decorator.</p>
      <p>In child.html file,</p>
      <pre>
        &lt;button (click)="onAddServer()"&gt;&lt;/button&gt;
      </pre>
      <p>In child.ts file,</p>
      <pre>
        serverOS = ''     ## Two way binded with input field
        serverVersion = ' '     ## Two way binded with input field
        @Output() serverAdded = new EventEmitter&lt;{os: string, version:string}&gt;()
        onAddServer(){
          this.serverAdded.emit({os: serverOS, version: serverVersion})
        }
      </pre>
      <p>In parent.html file,</p>
      <pre>
        &lt;app-child (serverAdded)="onServerAdded($event)"&gt;&lt;/app-child&gt;
      </pre>
      <p>In parent.ts file,</p>
      <pre>
        onServerAdded(serverdata:{os: string, version:string}){
          do something
        }
      </pre>
      <p>We can bind throuh alias, instead of using direct event name.</p>
      <pre>
        @Output("alias name"), then in parent html file ("alias name")="data".
      </pre>
    </section>
    <section>
      <h2>Style Encapsulation</h2>
      <p>Lets say, parent component has a style, p{color:blue}.</p>
      <p>Now this style will only apply to the components that are inside app component html file.</p>
      <p>It wont apply to any of its child component, though they are inside app component.</p>
      <p>This is called view encapsulation.</p>
      <p>Angular does that by assiging each element inside the component a unique and same attribute.</p>
      <p>Then Angular changed the above style to, p[attribute_name]{color:blue}</p>
      <p>We can override this behavior by adding a property in component decorator.</p>
      <pre>
        @Component({
          .........
          encapsulation: ViewEncasulation.None  ## Disable adding attribute, thus no encapsulation.
          encapsulation: ViewEncasulation.Native ## Apply shadow dom technique if browser supports.
          encapsulation: ViewEncasulation.Emulated ## Default, encapsulation enabled.
        })
      </pre>
    </section>
    <section>
      <h2>Template Reference</h2>
      <p>In general, we two way bind input field with typescript variable, so that we can capture user input.</p>
      <p>But this process update variable for every input change.</p>
      <p>Instead of updating varible for every input, we can use template reference to get input data when needed.</p>
      <p>In html file,</p>
      <pre>
        &lt;input type="text" #nameInput&gt;  ## We are adding a reference to this input field.
        &lt;button (click)="onAddName(nameInput)"&gt;&lt;/button&gt;
      </pre>
      <p>We can directly use this reference in html file only, not in ts file.</p>
      <p>So we pass this as an argument of onAddName() method to use it inside ts file.</p>
      <p>Here #nameInput refers to the whole input element.</p>
      <p>In ts file,</p>
      <pre>
        onAddName(inputdata : HTMLInputElement){
          console.log(inputdata.value)  ## We can use this value now.
        }
      </pre>
      <p>There is another way to access any html element from typescript without passing them through method.</p>
      <p>In html file,</p>
      <pre>
        &lt;input type="text" #nameInput&gt;
        &lt;button (click)="onAddName()"&gt;&lt;/button&gt;  ## We no longer pass the reference.
      </pre>
      <p>In ts file,</p>
      <pre>
        @ViewChild('nameInput',{static:true/false}) nameData : ElementRef
        onAddName(){
          console.log(this.nameData.nativeElement.value)
        }
      </pre>
      <p>Here nameData refers to html element and to get that element, we use nativeElement property.</p>
      <p>
        { static: true } as a second argument needs to be applied to all usages of @ViewChild() (and also @ContentChild() discussed later)
        if we plan on accessing the selected element inside of ngOnInit(). If we don't access the selected element in ngOnInit 
        (but anywhere else in our component), we will set static: false instead! This is a temporary adjustment which will not be 
        required anymore once Angular 9 is released!
      </p>
    </section>
    <section>
      <h2>Html Code Inject</h2>
      <p>Let say we have a component named test component with selector &lt;app-test&gt;</p>
      <p>Inside parent component,</p>
      <pre>
        &lt;app-test&gt;...Any html code or anything thing we write here would not be rendered by angular...&lt;/app-test&gt;
      </pre>
      <p>But we can use <span>ng-content</span> to render html.</p>
      <p>Inside test component html file,</p>
      <pre>
        &lt;div&gt;
          &lt;h1&gt;Hello world&lt;/h1&gt;
          &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/div&gt;
      </pre>
      <p>Now whatever we write between &lt;app-test&gt; ... &lt;/app-test&gt; will replace &lt;ng-content&gt;&lt;/ng-content&gt;</p>
      <p>Previously, We use @ViewChild() to access referenced element of a component's own template.</p>
      <p>But if the html code is projected via ng-content, thus any refernce in that code can be access from parent compoent.</p>
      <p>To access this reference from child component, we have to use <span>@ContentChild()</span>.</p>
      <p>Inside parent component html file,</p>
      <pre>
        &lt;app-test&gt;&lt;p #demo&gt;Hello&lt;/p&gt;&lt;/app-test&gt;
      </pre>
      <p>In test component ts file,</p>
      <pre>
        @ContentChild('demo',{static:true/false}) demoref: ElementRef
      </pre>
    </section>
    <section>
      <h2>Component Lifecycle</h2>
      <p><span>Constructor</span>: called first.</p>
      <p>
        <span>ngOnChanges</span>: can be executed multiple times; executed right at the start when new component is created.
        Also called whenever our bound input property changes, that means @Input() decorated property receives new value. 
        Only method that receives argument: ngOnChanges(changes: SimpleChanges).
      </p>
      <p><span>ngOninit</span>: executed once the component is initialized but not displayed yet.</p>
      <p>
        <span>ngDoCheck</span>: can be executed multiple times; called during every change detection run. 
        Angular check the dom for various reason, and everytime angular check, this method will also run.
      </p>
      <p><span>ngAfterContentInit</span>: called after ng-content has been projected into view.</p>
      <p><span>ngAfterContentChecked</span>: called everytime the projected content has been checked.</p>
      <p>
        <span>ngAfterViewInit</span>: called after the component's view (and child views) has been initialized. Now 
        we can access template and reference template element.
      </p>
      <p><span>ngAfterViewChecked</span>: called every time the component's view (and child views) has been checked.</p>
      <p><span>ngOnDestroy</span>: called once the component is about to destroy.</p>
    </section>
    <section>
      <h2>Directive Advanced</h2>
      <p>Mainly two types: Attribute and Structural.</p>
      <p>Can not have more than one structural directive in the same element.</p>
      <p>So we can not use *ngIf and *ngFor together on same element, But we can use structural and attribute (multiple) directive together.</p>
      <p>We can create custom directive. For example,</p>
      <p>In demo.directive.ts file,</p>
      <pre>
        @Directive({
          selector: '[appDemo]'  ## Here we are using attribute styled selector and camel case format.
        })
        export class DemoDirective implements OnInit {
          constructor(private elementRef: ElementRef){}  ## Here elementRef refers to the element where our directive has been placed on.
          ngOnInit(){
            this.elementRef.nativeElement.backgroundColor = 'White'; 
          }
        }
      </pre>
      <p>Then in app.module.ts file we add,</p>
      <pre>
        @NgModule({
          declarations : [....., DemoDirective,...]
        })
      </pre>
      <p>Now we can use it on any component or element, like this,</p>
      <pre>
        &lt;p appDemo&gt;This is styled by demo directive&lt;/p&gt;
      </pre>
      <p>But accessing and then directly modifying element via ElementRef is not a good practice.</p>
      <p>Rather we can use <span>Renderer2</span>.</p>
      <pre>
        constructor(private elementRef: ElementRef, private renderer: Renderer2){}
        ngOnInit(){
          this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'green', 'optional-fourth-argument');
        }
      </pre>
      <p>We can also listen event from the element and write logics on directive based on the events.</p>
      <pre>
        @HostListener('mouseenter') mouseover(evendata: Event) {
          this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'green', 'optional-fourth-argument');
        }
      </pre>
      <p>
        Here mouseenter is a html event and when mouse enter on host element, this event emits. Directive listen to this event 
        and call mouseover method, thus changing host element background style.
      </p>
      <p>There is a shortcut to change host element style rather than using elementRef and renderer.</p>
      <pre>
        @HostBinding('style.backgroundColor') bgColor : String;
        ngOnInit(){
          this.bgColor = 'Red';
        }
      </pre>
      <p>Using hostbinding we can access properties of the element.</p>
      <p>Here we are defining background color by ourselves but we can make it dynamic.</p>
      <p>We can use the concept of property binding.</p>
      <p>In demo.directive.ts file,</p>
      <pre>
        @Input() color : String = 'red'
        @HostBinding('style.backgroundColor') bgColor : String;
        ngOnInit(){
          this.bgColor = this.color;
        }
      </pre>
      <p>In any component html file,</p>
      <pre>
        &lt;p appDemo [color]="'green'"&gt;This will be colored green&lt;/p&gt;
      </pre>
      <p>Here appDemo is the directive and color is it's property</p>
      <p>Angular can determine which property comes from directive and which property comes from component itself.</p>
      <p>Suppose, color is the only property of this decorator. Then we can alias it in directive selector name.</p>
      <pre>
        @Input('appDemo') color : String = 'red'
      </pre>
      <p>Then in html file we can write,</p>
      <pre>
        &lt;p [appDemo]="green"&gt;This will be colored green&lt;/p&gt;
      </pre>
      <p>This is what happened with [ngClass] and [ngStyle] directive.</p>
      <p>Lets discuss about structural directive.</p>
      <p> We use * before structural directive but behind the scene it converts into something else.</p>
      <pre>
        &lt;div *ngIf=""&gt;....&lt;/div&gt;
      </pre>
      <p>But it converts to our familiar property binding.</p>
      <pre>
        &lt;ng-template [ngIf]=""&gt;
          &lt;div&gt;...&lt;/div&gt;
        &lt;/ng-template&gt;
      </pre>
      <p>Lets create a structural directive that works exactly opposite of ngIf.</p>
      <pre>
        @Directive({
          selector: 'appUnless'
        })
        @Input('appUnless') set unless(condition: boolean) {
          if(!condition) {
            this.vcRef.createEmbeddedView(this.templateRef);
          } else {
            this.vcRef.clear();
          }
        }
        ## This a shortcut. Here unless is a property and we define a setter for it.
        ## Thus when unless propety changes from outside, the above method will be called.
        constructor(private templateRef: TemplateRef&lt;any&gt;, private vcRef: ViewContainerRef){
          ## Here we use TemplateRef to get refernce of ng-template; This is 'what' we will render.
          ## We use ViewContainerRef to get refernce to 'where' we will render it.
        }
      </pre>
      <p>Now in component file,</p>
      <pre>
        &lt;div *appunless=""&gt;....&lt;/div&gt;
      </pre>
      <p>Shortcut for creating directive: <span>ng g d 'name'</span></p>
    </section>
    <section>
      <h2>Service</h2>
      <p>Simple typescript class without any decorator like @Component() or @Directive().</p>
      <p>Holds some fucntionallity and methods that will be used in various components.</p>
      <p>In demo.service.ts,</p>
      <pre>
        export class DemoService {
          doSomething(arg){
            console.log(arg);
          }
        }
      </pre>
      <p>In general, we can simply import the class, create an instance and call the methods.</p>
      <p>For example, In any.component.ts file,</p>
      <pre>
        import { DemoService } from ......
        ds = new DemoService();
        ds.doSomething("hi");
      </pre>
      <p>But thats not the best practice. Rather we let Angular create the instance for us.</p>
      <p>In any.component.ts file,</p>
      <pre>
        constructor(private ds : DemoService){}
        this.ds.doSomething("hi");
      </pre>
      <p>
        Here, by adding a variable with type Demoservice in the constructor, we tell Angular to provide 
        us an instance of Demoservice when Angular creates the component.
      </p>
      <p>But that alone is not enough. Because now Angular knows what you need but it does not know how to
        get it. So we have to add the following line inside @Component() decorator.</p>
      <pre>
        @Component({
          .....
          providers: [DemoService]
        })
      </pre>
      <p>This tells Angular who will provide the instance.</p>
      <p>Lets say we have two components from two different component tree.</p>
      <p>If we use a service in both of them in the above method, Angular will provide two different instance for them.</p>
      <p>Now if the service has some data storage like array or variables, updating them in one of the component's service won't affect the other. </p>
      <p>This behavior of Angular is called Hierarchial Injector.</p>
      <p>
        If we inject a service in a component, that component and all of its children will receive the exact 
        same instance of that service. Any other component will not have any access to that instance of the service.
      </p>
      <p>So we can inject a service in the AppModule to make one common instance accessible for every components and services in the app.</p>
      <p>Lets say, app component has two child components: abc & xyz.</p>
      <p>To provide same instance of DemoService to both of them, we add DemoService in the providers array of app component.</p>
      <p>
        Then in abc and xyz component we no longer add this service in their providers array. If we do, then Angular will
        create seperate instance for each of these components.
      </p>
      <p>But we have to declare a variable of DemoService in constructor of both of them like before.</p>
      <p>We can inject a service into another service and the procedure is almost same as before.</p>
      <p>But service doesnot have any metadata (stored in decorators i.e @Component()) like component and directive does.</p>
      <p>So we have to add <span>@Injectable()</span> on top of the second service class where we are injecting the first service.</p>
      <pre>
        @Injectable()
        export class DemoService2 (){
          constructor(private ds:DemoService){}
        }
      </pre>
      <p>We can also provide application-wide services in a different way.</p>
      <p>Instead of adding a service class to the providers[] array in AppModule, we can set the following config in the service itself,</p>
      <pre>
        @Injectable({providedIn: 'root'})
        export class MyService { ... }
      </pre>
      <p>Using this new syntax is completely optional, the traditional syntax (using providers[] ) will still work.</p>
      <p>
        The "new syntax" does offer one advantage though: Services can be loaded lazily by Angular (behind the scenes) 
        and redundant code can be removed automatically.
      </p>
    </section>
    <section>
      <h2>Routing</h2>
      <p>Suppose, app comonent has tree child component: home, student, teacher.</p>
      <p>In app.component.html file,</p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Teacher&lt;/a&gt;
        &lt;/div&gt;
        &lt;app-home&gt;&lt;/app-home&gt;
        &lt;app-student&gt;&lt;/app-student&gt;
        &lt;app-teacher&gt;&lt;/app-teacher&gt;
      </pre>
      <p>
        Here these components are shown together but we want to show them individually whenever we click corresponding
        link. We can solve this using routing.
      </p>
      <p>In app.module.ts file,</p>
      <pre>
        import { Routers, RouterModule } from '@angular/router';
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent },
          { path: 'teachers', component: TeacherComponent }
        ]
        @NgModule({
          imports: [
            ......
            RouterModule.forRoot(appRoutes)
          ]
        })
      </pre>
      <p>Now in app.component.html file,</p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Teacher&lt;/a&gt;
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;  ## router-outlet is a directive, not a component.
      </pre>
      <p>
        Now we can visit each component individually by browsing their urls. But we still cannot change url by clicking the links yet. 
        We can do the followings,
      </p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a href="/"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a href="/students"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a href="/teachers"&gt;Teacher&lt;/a&gt;
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;
      </pre>
      <p>
        Now we can click on any link and it will take us to corresponding component. But this method is not ok because it will
        reload/restart the whole app. Thus we may lose current state of the app and many other things. So this is not how we will
        navigate in our app.
      </p>
      <p>Instead of using href we can use <span>routerLink</span></p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a routerLink="/"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a routerLink="/students"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a [routerLink]="['/teachers']"&gt;Teacher&lt;/a&gt;  ## We can use property binding.
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;
      </pre>
      <p>
        Note that, we have used '/' as a prefix in 'students' and 'teachers'. If we use 'students' instead of '/students', Angular will
        treat it as a relative path. For example, if we have a button in student component with routerLink="students", then Angular will
        think it as 'localhost:4200/students/students'. Similarly, './students' will generate same url. But we can use '../students' for
        'localhost:4200/students'. That is, we go up one level, then add 'students' to url. Thus we can use '../../students' if needed.
      </p>
      <p>
        Right now we get no visual indication of what the currently active route is. Home component selector has class="active" in it. 
        It would be nice if we can add or remove this class on each element dynamically.
      </p>
      <p>
        For that we will use <span>routerLinkActive</span> directive provided by Angular. It will apply any css class provided
        by us to the element if it is currently the active element. 
      </p>
      <pre>
        &lt;li routerLinkActive="active"&gt;&lt;a routerLink="/"&gt;Home&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a routerLink="/students"&gt;Student&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a [routerLink]="['/teachers']"&gt;Teacher&lt;/a&gt;
      </pre>
      <p>
        Now whenever we click on a link, active class will be applied to it. But problem is, home component url is always
        active becuase routerLinkActive matches paths and home compoent path '/' exists in all other compoent paths. SO we have to
        check if path is exactly matched. So we can add special configurtaion on our routerLinkActive directive.
      </p>
      <pre>
        &lt;li routerLinkActive="active" [routerLinkActiveOptions]="{exact:true}"&gt;&lt;a routerLink="/"&gt;Home&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a routerLink="/students"&gt;Student&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a [routerLink]="['/teachers']"&gt;Teacher&lt;/a&gt;
      </pre>
      <p>So far we have loaded route via link. But we can also navigate from a function</p>
      <pre>
        constructor(private router:Router){}
        onLoadStudents(){
          this.router.navigate(['/students']);
        }
      </pre>
      <p>
        Now if we use relative path inside navigate() i.e if we use 'students' instead of '/students', it will work same. Previously we
        have used this approach and it would create this url, 'localhost:4200/students/students' but unlike the routerLink, navigate method 
        does not know on which route we are currently on. So it will start from 'localhost:4200'. But we can tell it our current route
        by passing a second argument inside navigate(). 
      </p>
      <pre>
        constructor(private router:Router, private route:ActivatedRoute){}
        onLoadUser(){
          this.router.navigate(['/students'], {relativeTo:this.route});
        }
      </pre>
      <p>We can add parameter to our routes to generate urls for dynamic components.</p>
      <p>In app.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students/:id/:name', component: StudentDetailsComponent },
          .......
        ]
      </pre>
      <p>In studentdetails.component.ts file,</p>
      <pre>
        student : {id:number, name:string};
        constructor(private route:ActivatedRoute){}
        ngOnInit(){
          this.student = {
            id : this.route.snapshot.params['id'],  ## id will be a string, so we may need to convert it into number.
            name : this.route.snapshot.params['name']
          }; 
        }
      </pre>
      <p>In studentdetails.component.html file,</p>
      <pre>
        {{ student.id}} {{ student.name }}
      </pre>
      <p>Now we can visit 'localhost:4200/students/1/john' from the browser. It will render StudentDetailsComponent with given id and name.</p>
      <p>Lets add the following codes inside studentdetails.component.html file,</p>
      <pre>
        {{ student.id}} {{ student.name }}
        &lt;a [routerLink]="['/students',2,'Alex']"&gt;Check Alex&lt;/a&gt;  ## localhost:4200/students/2/Alex
      </pre>
      <p>
        If we click on 'Check Alex', we see that the url on the browser has changed to the one we have expected but the component did not change. 
        This is not a bug, rather the default behavior of Angular. We are currently on StudentDetailsComponent and we are trying to visit StudentDetailsComponent
        again. Thus Angular won't re-render the component. Though we are passing new data, Angular does not know that. To tell Angular to re-render
        this component with new data, we add the following codes inside studentdetails.component.ts file,
      </p>
      <pre>
        ngOnInit(){
          this.student = {
            id : +this.route.snapshot.params['id'],      ## add '+' to convert string to number.
            name : this.route.snapshot.params['name']
          }; 
          ## route.params is an observable.
          this.route.params.subscribe( (prms:Params) => {
            this.student.id = +prms['id'];
            this.student.name = prms['name'];
          })
        }
      </pre>
      <p>
        We can also pass query parameters and fragments with our url (localhost:4200/teachers/2?age=55&nid=12345#editing) 
        and somehow we have to retrieve these informations. To show how to do this, first we add another route in app.module.ts file,
      </p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'teachers/:id/edit', component:EditTeacherComponent },
          .......
        ]
      </pre>
      <p>Now in teacher.component.html file,</p>
      <pre>
        &lt;a 
          [routerLink]="['/teachers', 2, 'edit']"  ## [routerLink]="['/teachers', teacher.id, 'edit']"
          *ngFor="let teacher of teachers"
        &gt;{{ teacher.name }}&lt;/a&gt;
      </pre>
      <p>
        Suppose we want to add a query parameter 'allowEdit' which will determine the permission of editing. Instead of adding it inside the array,
        we will use property binding.
      </p>
      <pre>
        &lt;a 
          [routerLink]="['/teachers', 2, 'edit']" 
          [queryParams]="{ allowEdit:'1'}"  ## Not a directive, rather a property of routerLink directive.
          *ngFor="let teacher of teachers"
        &gt;{{ teacher.name }}&lt;/a&gt;
      </pre>
      <p>Clicking on the link will now generate the follwing url, localhost:4200/teachers/2/edit?allowEdit=1. We can also add fragment,</p>
      <pre>
        &lt;a 
          [routerLink]="['/teachers', 2, 'edit']" 
          [queryParams]="{ allowEdit:'1'}" 
          [fragment]="'loading'"
          *ngFor="let teacher of teachers"
        &gt;{{ teacher.name }}&lt;/a&gt;
      </pre>
      <p>Now the generated url is, localhost:4200/teachers/2/edit?allowEdit=1#loading</p>
      <p>We can also do the samething inside function.</p>
      <pre>
        constructor(private router:Router){}
        onLoadTeacher(id:number){
          this.router.navigate(['/teachers', id, 'edit'], {queryParams: {allowEdit:'1'}, fragment: 'loading'});
        }
      </pre>
      <p>Now we will see how to retrieve this information.</p>
      <pre>
        constructor(route:ActivatedRoute){}
        ngOnInit(){
          console.log(this.route.snapshot.queryParams);
          console.log(this.route.snapshot.fragment);
        }
      </pre>
      <p>Now this approach will create the same re-rendering problem. So like params, we can also subscribe to queryParams and fragment.</p>
      <pre>
        constructor(route:ActivatedRoute){}
        ngOnInit(){
          .......
          this.route.queryParams.subscribe();
          this.route.fragment.subscribe();
        }
      </pre>
      <p>Lets discuss about child routing. Suppose we have the following routes,</p>
      <pre>
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent },
          { path: 'students/:id', component: StudentDetailsComponent},
          { path: 'students/:id/edit', component: EditStudentComponent},
          { path: 'teachers', component: TeacherComponent },
          { path: 'teachers/:id', component: TeacherDetailsComponent }
        ]
      </pre>
      <p>We can rewrite these as follows,</p>
      <pre>
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]},
          { path: 'teachers', component: TeacherComponent, children: [
            { path: ':id', component: TeacherDetailsComponent}
          ]}
        ]
      </pre>
      <p>
        Now we can only render top level component inside router-outlet of app-component. So child routes of student component
        need seperate router-outlet inside student component html file. 
      </p>
      <p>
        Suppose we want to pass query params from one link to another. For example, student compnent has some query params in its url 
        and we want these to carry forward to student edit component url. In that case, we configue as follows,
      </p>
      <pre>
        constructor(private router:Router, private route:ActivatedRoute){}
        onEditStudent(id:number){
          this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'reserve/merge'});
          ## reserve -> when we do not add any new query params.
          ## merge -> when we add more new query params.
        }
      </pre>
      <p>What will happen when someone tries to visit a page that doesnot exists? We may show 404 message or simply redirect them to another page.</p>
      <p>Lets start with redirecting.</p> 
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'not-found', component: PageNotFoundComponent },
          { path: '**', redirectTo: '/not-found'}  ## wildcard routing; catch all unseen urls; so it must be last path in this array.
        ]
      </pre>
      <p>In general if we have more than 2 or 3 routes, it is better to define them in a seperate module.</p>
      <p>In app-routing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]},
          { path: 'teachers', component: TeacherComponent, children: [
            { path: ':id', component: TeacherDetailsComponent}
          ]}
        ]

        @NgModule({
          imports: [
            RouterModule.forRoot(appRoutes)  ## We configured routermodule.
          ],
          exports: [
            RouterModule    ## Now, we export it for app module.
          ]
        })
        export class AppRoutingModule {
        }
      </pre>
      <p>
        Now we simply add AppRoutingModule in the imports array of app module. Note that, ordering is important while working with dynamic route. 
        Lets say, we want to add url 'students/new'. If we add this 'new' path after ':id' path in the children array, Angular will think 'new' as 
        a param. So fixed url patterns must be declared before dynamic patterns.
      </p>
      <p>
        Lets discuss about route guards: functionallity, logic, code which is executed when a route is loaded or when we leave a route. 
        We may want to prevent a user from accessing certain routes. We can write code inside ngOnInit of each component but that is totally
        inefficient. Rather we can use <span>canActivate</span> provided by Angular.
      </p>
      <p>Lets create a service which will works as a fake auth service. Inside auth.service.ts file,</p>
      <pre>
        export class AuthService {
          loggedIn = false;

          isAuthenticated() {
            const promise = new Promise(
              (resolve, reject) => {
                setTimeout(() =>{              ## mimicking a server call which will take some time.
                  resolve(this.loggedIn);
                }, 8000)
              }
            );
            return promise;
          }

          login() {
            this.loggedIn = true;
          }

          logout() {
            this.loggedIn = false;
          }
        }
      </pre>
      <p>Now we create a service named auth-guard. Inside auth-guard.service.ts file,</p>
      <pre>
        import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';
        import { Observable } from 'rxjs/Observable';
        import { Injectable } from '@angular/core';
        import { AuthService } from './auth.service';

        @Injectable()
        export class AuthGuard implements CanActivate {
          constructor(private authService: AuthService, private router: Router){}

          canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
            Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            return this.authService.isAuthenticated().then(
              (authenticated: boolean) => {
                if (authenticated) {
                  return true;
                } else {
                  this.route.navigate(['/']);
                }
              }
            );
          }
        }
      </pre>
      <p>Our guard is ready. Suppose we want to apply this guard in student component route. Inside app-rotuing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', canActivate: [AuthGuard],  component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]}
        ]
      </pre>
      <p>Here authguard will be applied to student component route and all of its child routes. We can add multiple guard.</p>
      <p>
        Suppose we want to access student component freely but put restriction on it's child components. For that we can put 
        canActivate on child components but there is a better approach for that. We have to implement <span>CanActivateChild</span>.
      </p>
      <pre>
        @Injectable()
        export class AuthGuard implements CanActivate, CanActivateChild {
          constructor(private authService: AuthService, private router: Router){}

          canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
            Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            ........
          }

          CanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
            Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            return this.canActivate(route, state);
          }
        }
      </pre>
      <p>Now apply this on student component route.</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', CanActivateChild: [AuthGuard],  component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]}
        ]
      </pre>
      <p>Now we will control whether a user can leave a route.</p>
      <p>For example, we may ask the user to confirm before leaving the student edit page.</p>
      <p>In edit-student.component.ts file,</p>
      <pre>
        changesSaved = false;

        onUpdateStudent() {
          .......
          this.changesSaved = true;
          this.router.navigate(['../'], {relativeTo: this.route});
        }
      </pre>
      <p>
        So we check the state of 'changesSaved' and decide whether a user can leave the route or not. To prevent leaving, 
        we have to execute some logic inside student edit component. But route guard is usually of type service becuase we will
        provide it in the routing module. So somehow we need to access the code in our edit component and also have a service. Though 
        it seems to be a complex task, we can handle it as follows,
      </p>
      <p>Lets add a service named can-deactivate-guard. Inside can-deactivate-guard.service.ts file,</p>
      <pre>
        import { CanDeactivate } from '@angular/router';
        import { Observable } from 'rxjs/Observable'

        export interface CanComponentDeactivate {
          canDeactivate: () => Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;
        }

        export class canDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt;{
          ## This method will be called by Angular whenever user try to leave the route.
          canDeactivate(component: CanComponentDeactivate, 
                        currentroute: ActivatedRouteSnapshot, 
                        currentstate: RouterStateSnapshot,
                        nextState?: RouterStateSnapshot):       ## '?' means optional parameter.
                        Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            return component.canDeactivate();
          }
        }
      </pre>
      <p>Now inside app-routing module,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent, canDeactivate: [canDeactivateGuard]}
          ]}
        ]
      </pre>
      <p>Now we have to implement CanComponentDeactivate in student edit component.</p>
      <pre>
        export class EditStudentComponent implements Oninit, CanComponentDeactivate {
          ........
          canDeactivate() : Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            if ( !this.changesSaved ) {
              return confirm("Do you want to leave?");
            } else {
              return true;
            }
          }
        }
      </pre>
      <p>
        We can also pass static data with route without using query params or some other means. For example we may have a 
        generic error component and wwe want to pass error message with the route. We can do that as follows,
      </p>
      <p>In app-routing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'not-found', component: ErrorComponent, data: {message: 'Page Not Found'}},
          { path: '**', redirectTo: '/not-found'}  
        ]
      </pre>
      <p>In error.component.ts file,</p>
      <pre>
        errorMessage: string;

        constructor(private route: ActivatedRoute){}

        ngOnInit() {
          this.route.data.subscribe(
            (data: Data) => {
              this.errorMessage = data['message'];
            }
          );
        }
      </pre>
      <p>
        Lets see how we can also pass dynamic data with a route. For example, inside student details component, we may want to
        show dynamic data (may be loaded from server) for individual student. Yes, we can do that inside the ngOninit function
        but we can also do the same before loading the route. For that we need a resolver (a service) which will allow us to run some code
        before the route is rendered. 
      </p>
      <p>In student-resolver.service.ts file,</p>
      <pre>
        import { Resolve } from '@angular/router';

        interface Student {
          id: number;
          name: string;
        }

        export class StudentResolver implements Resolve&lt;Student&gt; {
          resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
                  Observable&lt;Student&gt; | Promise&lt;Student&gt; | Student {
            return this.someservice.getStudent(+route.params['id'])   ## for refernce, see previous example codes.
          } 
        }
      </pre>
      <p>In app-routing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent, resolve: {sr: StudentResolver}},
            .....
          ]}
        ]
      </pre>
      <p>In student-details.component.ts file,</p>
      <pre>
        student: {id:number, name:string};

        ngOninit() {
          this.route.data.subscribe(
            (data: Data) => {
              this.student = data['sr'];
            }
          );
        }
      </pre>
      <p>
        Now here's one important thing, so far the way we have used routes works fine here on our local setup but actually, 
        If we have a route like this and we are hosting this on a real server somewhere, this might not work out of the box.
        Because there, routes, the URL is always parsed & handled by the server which hosts our application. The server 
        hosting our Angular single page application has to be configured such that in a case of a 404 error, it returns the 
        index.html file, the file starting and containing our Angular app. As all our URLs are parsed by the server first 
        (not by Angular), now if we have /students there, it will look for a /students route on our server. Now chances are 
        we don't have that route here because we only have one file there, index.html containing our Angular app and we want 
        Angular to take over and parse this route but it will never get a chance. Rather our hosting server will show 404 page. 
        Therefore we need to make sure that in such a case, our web server returns the index.html file. (More in deploy section)   
      </p>
    </section>
    <section>
      <h2>Observable</h2>
      <p>
        It can be data sources, user input events, http requests or something triggered in the code. Between observer & observable 
        there is a stream where observable emits data. An observer (more likely the codes we write) usually handle three types of things: 
        data, error & completion of observable. 
      </p>
      <p>Observables are constructs in which we subscribe to be informed about changes in data.</p>
      <p>For example, we have used params observable in routing section.</p>
      <p>Lets build our own observable and understand it's internals.</p>
      <p>Observable is provided by a package called <span>rxjs</span>. It gives us different ways to create an observable.</p>
      <pre>
        import { interval } from 'rxjs';

        ngOnInit() {
          interval(1000).subscribe( count => {
            console.log(count);
          });
        }
      </pre>
      <p>Here 'interval' is an observable provided by rxjs which will emit incremental number every 'n' seconds defined by us.</p>
      <p>
        Here if we go to some other component, we see that the interval observable do not stop emitting data. That's because 
        observable doesnot necessarily stop just because we are not interested any more. There are certain observables that emit some 
        values and then they are done, i.e http observables, but some observables may continue emitting data. To stop that we have to
        unsubscribe the observable.
      </p>
      <pre>
        import { interval, Subscription } from 'rxjs';

        private obsSubs: Subscription;

        ngOnInit() {
          this.obsSubs = interval(1000).subscribe( count => {
            console.log(count);
          });
        }

        ngOnDestroy() {
          this.obsSubs.unsubscribe();
        }
      </pre>
      <p>So far we have only implemented an observable provided by rxjs. Now we will rebuild this interval observable by ourself.</p>
      <pre>
        import { Observable, Subscription } from 'rxjs';

        private obsSubs: Subscription;

        ngOnInit() {
          const customIntervalObservable = Observable.create(observer => {
            let count = 0;
            setInterval(()=>{
              observer.next(count);
              count++;
            },1000);
          })
          this.obsSubs = customIntervalObservable.subscribe( data => {
            console.log(data);
          });
        }

        ngOnDestroy() {
          this.obsSubs.unsubscribe();
        }
      </pre>
      <p>So we have built an observable that emits data. Lets see how we can throw error and other staffs.</p>
      <pre>
        ..............
        const customIntervalObservable = Observable.create(observer => {
          let count = 0;
          setInterval(()=>{
            observer.next(count);
            if (count > 10) {
              observer.error(new Error("Greater than 10!"));
            }
            count++;
          },1000);
        })

        this.obsSubs = customIntervalObservable.subscribe( data => {
          console.log(data);
        }, error => {
          console.log(error.message);
        });
      </pre>
      <p>To complete an observable,</p>
      <pre>
        ......
        const customIntervalObservable = Observable.create(observer => {
          let count = 0;
          setInterval(()=>{
            observer.next(count);
            if (count == 5) {
              observer.complete();
            }
            count++;
          },1000);
        })

        this.obsSubs = customIntervalObservable.subscribe( data => {
          console.log(data);
        }, () => {
          console.log("Completed");
        });
      </pre>
      <p>
        In general observable emits data and an observer subsribes to that observable. Now we may want to filter or transform the 
        raw data provided by observable and for that we put <span>operators</span> between observable and observer. Then we subscribe 
        to the result of the operators. Rxjs has lots of operators that we can use in our code.
      </p>
      <pre>
        import { map } from 'rxjs/operators';

        ......
        this.obsSubs = customIntervalObservable.pipe(map(data => {
          return 'Round: ' + (data+1);
        })).subscribe( data => {
          console.log(data);
        }, () => {
          console.log("Completed");
        });
      </pre>
      <p>Using pipe we can add mutltiple operators (comma seperated) in the observable.</p>
      <pre>
        import { filter, map } from 'rxjs/operators';

        ......
        this.obsSubs = customIntervalObservable.pipe(filter(data => {
          return data%2==0;     ## First this operator will run which only allow even number.
        }), map(data => {
          return 'Round: ' + (data+1);  ## Then this operator will run on filtered data.
        })).subscribe( .... );
      </pre>
      <p>
        We have seen in service section that we can establish communication between cross-components by creating event emitter in the service, 
        then emit it inside one component and subscribe to other component. Instead of EventEmitter, we can use <span>Subject</span>, a special
        observable provided by rxjs. Instead of calling emit(), we will now call next() method. The remaining procedure is same as before. Also we 
        have to unsubscribe when the component is destroyed. Using subject is more efficient than EventEmiiter for cross component communication 
        (not suitable for internal events i.e parent child communication) and we can also use operators with it.
      </p>
    </section>
    <section>
      <h2>Forms</h2>
      <p>Angular provides a javascript object representation of the form so that we can perform validation and send it to server.</p>
      <p>Two types: Template driven form & Reactive form.</p>
      <p>Template driven: Angular infers the form object from the dom.</p>
      <p>Reactive: Form is created programmatically and synchronized with the dom.</p>
      <p>
        Lets understand how Angular creates javascript representation of a form in template dirven approach. First of all, we have to import FormsModule 
        inside app.module.ts file.</p>
      <p>
        Suppose we have some input fields inside the form tag in our html file. By default, Angular wont detect input fields automatically. We have to add 
        <span>ngModel</span> directive in the input field and provide it a name (html attribute), which wil be used to represent it in javascript object. Now 
        how can we handle form submission and retrieve the javascript representation? Lets say, we have a method onSubmit() inside our .ts file. We can 
        call this method when user click the submit button, but the default behavior of submit button will also trigger a http call. So a better approach is,
      </p>
      <pre>
        &lt;form (ngSubmit)="onSubmit(myform)" #myform&gt;
        .......
        &lt;/form&gt;
      </pre>
      <p>
        Here ngSubmit will capture the default event fired by submit button and call onSubmit() method. We have passed a reference of this form 
        as a parameter to use it inside our .ts file. We can also use ViewChild decorator instead of passing the ref as a parameter. In that way 
        we can use the form before user submit it.
      </p>
      <pre>
        onSubmit(form: HTMLInputElement) {
          console.log(form);   ## Will show a html representation of the form
        }
      </pre>
      <p>To get the javascript representation we have to do one more thing. We update the form reference as,</p>
      <pre>
        &lt;form (ngSubmit)="onSubmit(myform)" #myform="ngForm"&gt;
        .......
        &lt;/form&gt;

        onSubmit(form: NgForm) {
          console.log(form);   ## Will show a NgForm object.
        }
      </pre>
      <p>
        This NgForm object has a value property which is an object conatining our input elements & their values. NgForm also conatins lots of 
        properties i.e valid, invalid, dirty, touched, disabled etc. that can be useful to validate the form.
      </p>
      <p>
        Lets see how we can validate our form. As we are using template driven approach, our validation will be done inside the html file. 
        For example, we can add 'required' in the nput field. Though it is a html attribute, Angular will detect it and treat it as a selector 
        for a built-in directive available in Angular. We can also use Angular provided directive such as 'email' directive to make sure an input 
        field has valid email address. If any of the requirements of these directive is not met, Angular will treat the form as invalid. 
      </p>
      <p>Suppose we have the following codes inside the html file,</p>
      <pre>
        &lt;input type="email" id="email_addr" ngModel name="email_addr" required email /&gt;
      </pre>
      <p>If we look at the html code generated by Angular, we will see that Angular add some extra classes such as,</p>
      <pre>
        &lt;input class="ng-dirty ng-untouched ng-invalid" type="email" id="email_addr" 
            name="email_addr" ngmodel  required ng-reflect-name="email" /&gt;
      </pre>
      <p>
        Now based on whether user touched the input field or not, whether input field is valid or not, these classes will change. With that 
        information we can style the input field conditionally.
      </p>
      <p>
        For example, we can disable the submit button if form is invalid.
      </p>
      <pre>
        &lt;form (ngSubmit)="onSubmit()" #myform="ngForm"&gt;
        .......
          &lt;button type="submit" [disabled]="!myform.valid"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      </pre>
      <p>Also we can use these css classes provided by Angular and write our own styles. Inside css file,</p>
      <pre>
        input.ng-invalid.ng-touched {
          border: 1px solid red;
        }
      </pre>
      <p>Lets add a helper text if user gives invalid email address.</p>
      <pre>
        &lt;input type="email" id="email_addr" ngModel name="email_addr" required email #emailRef="ngModel"/&gt;
        &lt;span *ngIf="!emailRef.valid && emailRef.touched"&gt;Please enter valid email address&lt;/span&gt;
      </pre>
      <p>We can provide default value to our input field via property binding,</p>
      <pre>
        &lt;input type="email" id="email_addr" 
            [ngModel]="you@example.com" 
            name="email_addr" required email #emailRef="ngModel"/&gt;
      </pre>
      <p>
        Note that we have also seen how we can apply two way binding between ngModel and a variable from ts file so that 
        we can react to every input changes.
      </p>
      <p>Suppose we have the following form,</p>
      <pre>
        &lt;form (ngSubmit)="onSubmit()" #myform="ngForm"&gt;
          &lt;div&gt;
            &lt;label&gt;Username&lt;/label&gt;
            &lt;input type="text" id="username" ngModel name="username" required/&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input type="email" id="email_addr" ngModel name="email_addr" required email/&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;label&gt;Select Role&lt;/label&gt;
            &lt;select id="role_select" ngModel name="role_select" required&gt;
              &lt;option value="s"&gt;Student&lt;/option&gt;
              &lt;option value="t"&gt;Teacher&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          &lt;button type="submit" [disabled]="!myform.valid"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      </pre>
      <p>If we fillup the form and hit submit button, Angular will provide us the following javascript object,</p>
      <pre>
        NgForm: {
          ......
          control: {
            username: FormControl,
            email_addr: FormControl,
            role_select: FormControl
          }
          ......
          value: {
            username: "abcd",
            email_addr: "test@example.com",
            role_select: "s"
          }
        }
      </pre>
      <p>
        Lets say, we want to group two or more input fields so that we can perform group validation or something else. We can 
        do this as follows,
      </p>
      <pre>
        &lt;form (ngSubmit)="onSubmit()" #myform="ngForm"&gt;
          &lt;div ngModelGroup="userdata" #uegroup="ngModelGroup"&gt;
            &lt;div&gt;
              &lt;label&gt;Username&lt;/label&gt;
              &lt;input type="text" id="username" ngModel name="username" required/&gt;
            &lt;/div&gt;
            &lt;div&gt;
              &lt;label&gt;Email&lt;/label&gt;
              &lt;input type="email" id="email_addr" ngModel name="email_addr" required email/&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;label&gt;Select Role&lt;/label&gt;
            &lt;select id="role_select" ngModel name="role_select" required&gt;
              &lt;option value="s"&gt;Student&lt;/option&gt;
              &lt;option value="t"&gt;Teacher&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          &lt;button type="submit" [disabled]="!myform.valid"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      </pre>
      <p>Now we will get the following js representation,</p>
      <pre>
        NgForm: {
          ......
          control: {
            userdata: FormGroup,
            role_select: FormControl
          }
          ......
          value: {
            userdata: {
              username: "abcd",
              email_addr: "test@example.com"
            },
            role_select: "s"
          }
        }
      </pre>
      <p>Let see how we can provide values to some input fields inside a form if user click a button or call a function.</p>
      <pre>
        @ViewChild('myform') myform: NgForm;
        onButtonClick () {
          this.myform.setValue({
            userdata: {
              username: "abcd",
              email_addr: ""
            },
            role_select: "s"
          })
        }
      </pre>
      <p>
        The drawback of this setValue() method is that we have to provide values for all input fields and thus it will replace any 
        existing values in the input fields that we do not want to set values. A better approach would be,
      </p>
      <pre>
        @ViewChild('myform') myform: NgForm;
        onButtonClick () {
          this.myform.form.patchValue({
            userdata: {
              username: "abcd"
            }
          })
        }
      </pre>
      <p>
        We can reset a form using setValue() method, though it will only reset values. We can use this to reset to some specific values. 
        To completely reset the form, it's values and properties, we can do the following.
      </p>
      <pre>
        this.myform.reset();
      </pre>
      <p>Now we will see the reactive form approach.</p>
      <p>First of all, we have to add ReactiveFormsModule instead of FormsModule.</p>
      <p>Inside ts file,</p>
      <pre>
        signupForm: FormGroup;

        ngOnInit () {
          this.signupForm = new FormGroup ({
            'username': new FormControl(initialvalue, single or array of validators, async validators),
            'email': new FormControl(null),
            'role': new FormControl('s')
          })
        }
      </pre>
      <p>Inside html file,</p>
      <pre>
        &lt;form [formGroup]="signupForm" (ngSubmit)="onSubmit()"&gt;
          &lt;div&gt;
            &lt;label&gt;Username&lt;/label&gt;
            &lt;input type="text" id="username" formControlName="username"&gt;  ## [formControlName]="'username'"
          &lt;/div&gt;
          &lt;div&gt;
            &lt;label&gt;Email&lt;/label&gt;
            &lt;input type="email" id="email_addr" formControlName="email"&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;label&gt;Select Role&lt;/label&gt;
            &lt;select id="role_select" formControlName="role"&gt;
              &lt;option value="s"&gt;Student&lt;/option&gt;
              &lt;option value="t"&gt;Teacher&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      </pre>
      <p>
        Here we have used ngSubmit just like template driven approach. But the main difference is, we no longer need to add 
        a form reference and pass it as an argument, because we have already declared the form in our ts file.
      </p>
      <pre>
        onSubmit () {
          console.log(this.signupForm);
        }
      </pre>
      <p>
        Low lets add some validation to this form. Previously we handled the validation in the template, but here everything will 
        be done inside the ts file. For example we can add required validation like this,
      </p>
      <pre>
        ngOnInit () {
          this.signupForm = new FormGroup ({
            'username': new FormControl(null, Validators.required),
            'email': new FormControl(null, [Validators.required, Validators.email]),
            'role': new FormControl('s')
          })
        }
      </pre>
      <p>
        Lets say we want to dispaly a message below the username input field if username is incorrect. In template driven approach 
        we would use the reference of ngModel to conditionally show the message. In reactive approach, we no longer use ngModel. But 
        we can use our overall form as a reference.
      </p>
      <pre>
        &lt;input type="text" id="username" formControlName="username"&gt;
        &lt;span *ngIf="signupForm.get('username').valid && signupForm.get('username').touched"&gt;
          Please enter valid username
        &lt;/span&gt;
      </pre>
      <p>We can also disable the submit button,</p>
      <pre>
        &lt;button type="submit" [disabled]="!signupForm.valid"&gt;Submit&lt;/button&gt;
      </pre>
      <p>
        Note that, just like template driven approach, Angular add ng-dirty, ng-touch etc classes in reactive approach too. So we can 
        use them to style just like before.
      </p>
      <p>Lets see how we can group our input elements here.</p>
      <pre>
        ngOnInit () {
          this.signupForm = new FormGroup ({
            'userdata': new FormGroup({
              'username': new FormControl(null, Validators.required),
              'email': new FormControl(null, [Validators.required, Validators.email])
            }),
            'role': new FormControl('s')
          })
        }
      </pre>
      <p>Then we have to update our template like this,</p>
      <pre>
        &lt;form [formGroup]="signupForm" (ngSubmit)="onSubmit()"&gt;
          &lt;div formGroupName="userdata"&gt;
            &lt;div&gt;
              &lt;label&gt;Username&lt;/label&gt;
              &lt;input type="text" id="username" formControlName="username"&gt;  ## [formControlName]="'username'"
            &lt;/div&gt;
            &lt;div&gt;
              &lt;label&gt;Email&lt;/label&gt;
              &lt;input type="email" id="email_addr" formControlName="email"&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;label&gt;Select Role&lt;/label&gt;
            &lt;select id="role_select" formControlName="role"&gt;
              &lt;option value="s"&gt;Student&lt;/option&gt;
              &lt;option value="t"&gt;Teacher&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
      </pre>
      <p>
        As username input field is now nested inside userdata formgroup, the warning message wont work anymore. We have to
        correct the path,
      </p>
      <pre>
        &lt;span *ngIf="signupForm.get('userdata.username').valid && signupForm.get('userdata.username').touched"&gt;
          Please enter valid username
        &lt;/span&gt;
      </pre>
      <p>Lets see how we can dynamically add input fields in our form when user clicks a button.</p>
      <pre>
        ngOnInit () {
          this.signupForm = new FormGroup ({
            .......
            'subjects': new FormArray([])
          })
        }

        onSubjectAdd () {
          var control = new FormControl(null, Validators.required);
          (&lt;FormArray&gt;this.signupForm.get('subjects')).push(control);
          ## Here type casting is mendatory.
        }
      </pre>
      <p>In html file,</p>
      <pre>
        &lt;div formArrayName="subjects"&gt;
          &lt;button type="button" (click)="onSubjectAdd()"&gt;Add Subject&lt;/button&gt;
          &lt;div *ngFor="let subjectControl of signupForm.get("subjects").controls, let i = index"&gt;
            &lt;input type="text" [formControlName]="i"&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      </pre>
      <p>Lets see how we can create custom validator.</p>
      <pre>
        forbiddenNames = ['Admin', 'Boss'];

        forbiddenNameCheck (control: FormControl) : {[s:string]: boolean} {
          if (this.forbiddenNames.indexOf(control.value) != -1) {
            return {'namIsForbidden'}: true;
          }
          return null;  ## do not return {'namIsForbidden'}: false; It doesn't work like this.
        }

        ngOnInit () {
          this.signupForm = new FormGroup ({
            'userdata': new FormGroup({
              'username': new FormControl(null, [Validators.required, this.forbiddenNameCheck.bind(this)]),
              ## Here bind is necessary because when Angular calls the function, 'this' doesnot refer to this class.
            }),
            .....
          })
        }
      </pre>
      <p>Now we can use the error messages to show different messages in the html.</p>
      <pre>
        &lt;span *ngIf="signupForm.get('userdata.username').valid && signupForm.get('userdata.username').touched"&gt;
          &lt;span *ngIf="signupForm.get('userdata.username').errors['nameIsForbiden']"&gt;
            Please enter a valid username.
          &lt;/span&gt;
          &lt;span *ngIf="signupForm.get('userdata.username').errors['required']"&gt;
           Username is required.
          &lt;/span&gt;
        &lt;/span&gt;
      </pre>
      <p>
        Sometimes we may need to communicate with the server to perform validation. In that case we will need async validator.
      </p>
      <pre>
        forbiddenEmailsCheck (control: FormControl) : Promise&lt;any&gt; | Observable&lt;any&gt; {
          const promise = new Promise&lt;any&gt;((resolve, reject) => {
            ## mimicking a server call
            setTimeout(()=>{
              if (control.value == 'abc@xyz.com') {
                resolve({'emailIsForbidden': true});
              } else {
                resolve(null);
              }
            }, 2000);
          });
        }

        ngOnInit () {
          this.signupForm = new FormGroup ({
            'userdata': new FormGroup({
              .......
              'email': new FormControl(null, [Validators.required, Validators.email], this.forbiddenEmailsCheck)
            }),
            ......
          })
        }
      </pre>
      <p>
        Our signupForm also gives us two obeservables: valueChanges & statusChanges. We can subscribe to these observables and 
        closely monitor our forms and react with every input changes.
      </p>
      <p>
        Like template driven approach, we can use setValue, patchValue and reset method exactly same way.
      </p>
    </section> 
    <section>
      <h2>Pipes</h2>
      <p>Pipes are features which allow us to transform output in the html file.</p>
      <p>Lots of built-in pipes are available which we can use in our template.</p>
      <pre>
        &lt;p&gt;{{username | uppercase}}&lt;/p&gt;
        &lt;p&gt;{{joiningdate | date}}&lt;/p&gt;
      </pre>
      <p>We can pass parameter to a pipe to futher customize our output.</p>
      <pre>
        &lt;p&gt;{{joiningdate | date:'fullDate'}}&lt;/p&gt;
        ## pipe:param1:param2 ...etc
      </pre>
      <p>We can apply multiple pipes by nesting them togther. Note that they will be applied from left to right.</p>
      <pre>
        &lt;p&gt;{{joiningdate | date:'fullDate' | uppercase}}&lt;/p&gt;
      </pre>
      <p>Lets make our own pipe which will shorten any given string.</p>
      <p>Inside shorten.pipe.ts file,</p>
      <pre>
        @Pipe({
          name: 'shorten'
        })
        export class ShortenPipe implements PipeTransform {
          transform(value: any) {
            return value.substr(0,10);
          }
        }
      </pre>
      <p>Then we have to add this class in declarations array inside app.module.ts file. Now we can use it like this,</p>
      <pre>
        &lt;p&gt;{{username | shorten}}&lt;/p&gt;
      </pre>
      <p>Now we will add parameter to this pipe,</p>
      <pre>
        @Pipe({
          name: 'shorten'
        })
        export class ShortenPipe implements PipeTransform {
          transform(value: any, limit: number) {
            if(value.length > limit) {
              return value.substr(0,limit);
            }
            return value;
          }
        }

        ## Inside html file,
        &lt;p&gt;{{username | shorten:10}}&lt;/p&gt;
      </pre>
      <p>
        Angular rerun pipe whenever it's input parameter changes but it won't rerun it when the variable/array/data/anything on which 
        we are applying the pipe changes. Angular does that to boost performance. But we can force Angular to calulate pipe everytine
        by adding following property,
      </p>
      <pre>
        @Pipe({
          name: 'shorten',
          pure: false
        })
      </pre>
      <p>
        There is a built-in pipe called <strong>async</strong> that we can use on data that is currently not available in the dom but will 
        be availble after some momemnts (may be coming from a server).
      </p>
    </section>
    <section>
      <h2>Http</h2>
      <p>First we have to add HttpClientModule in app.module.ts file. Then we have to ineject it into the component where we will use it.</p>
      <p>In app.component.ts file,</p>
      <pre>
        constructor(private http: HttpClient){}

        onCreateUser(data: {name:string, age: number}) {
          this.http.post(
            url, 
            data
          ).subscribe(responseData => {
            console.log(responseData);
          });
        }
      </pre>
      <p>
        Here, we send data which is a js object but Angular will convert it to json before sending. Http request are managed by
        observable. So if we are not subscribing to this observable, Angualr won't send any http request. 
      </p>
      <p>Lets send a get request to the server.</p>
      <pre>
        onFetchUsers() {
          this.http.get(
            url
          ).subscribe(responseData => {
            console.log(responseData);
          });
        }
      </pre>
      <p>We can also use filter or transform the responseData using operators.</p>
      <pre>
        onFetchUsers() {
          this.http.get(
            url
          ).pipe(map(responseData=>{
            do something..
          })).subscribe(convertedData => {
            console.log(convertedData);
          });
        }
      </pre>
      <p>Currently responseData is of type any. But we can provide data type following ways,</p>
      <pre>
        onFetchUsers() {
          this.http.get&lt;datatype&gt;(               ## We can provide type here.
            url
          ).pipe(map((responseData: datatype)=>{  ## Or, We can provide type here.
            do something..
          })).subscribe(convertedData => {
            console.log(convertedData);
          });
        }
      </pre>
      <p>
        In general, our component should only handle functionallities related to templates, thus we should write all http codes 
        inside a service and use that service in our component. If our component does not need to react to the response data of 
        an api call, then all associated code will go to the service. But if we need the response data (for example, get call), then 
        the all codes except subscription part will be inside the service and we will call subscribe inside our component, thus we can 
        react to newly arrived data.
      </p>
      <p>In order to send a delete request,</p>
      <pre>
        this.http.delete(url).subscribe(response => {});
      </pre>
      <p>Lets see how we can handle errors.</p>
      <pre>
        onFetchUsers() {
          this.http.get(
            url
          ).pipe(map(responseData=>{
            do something..
          })).subscribe(
            convertedData => {
              console.log(convertedData);
            }, 
            error => {
              console.log(error.message, error.status)
            }
          );
        }
      </pre>
      <p>
        The above method will work if subscribe method is inside our component but sometimes we may not need the response data (post call), 
        thus subscribe method will be inside the service. In that case we can either move that fucntion inside our component and everything will 
        be fine. But there is another way to handle this situation.
      </p>
      <pre>
        ## Inside the service,
        error = new Subject&lt;datatype&gt;();
        onFetchUsers() {
          ........
            error => {
              this.error.next(error.message)
            }
          );
        }

        ## Inside the component,
        private errorSub: Subscription;
        constructor(private service: OurService){}

        ngOnInit() {
          this.errorSub = this.service.error.subscribe(errorMessage => {});
        }

        ngOnDestroy() {
          this.errorSub.unsubcribe();
        }
      </pre>
      <p>
        In some cases we may have some generic error handling task. In that case we can use operator to catch error, perform 
        some task and after that throw it as an observable.
      </p>
      <pre>
        onFetchUsers() {
          this.http.get(
            url
          ).pipe(
            map(responseData=>{
              ....
            },
            catchError(errorResponse =>{      ## catchError and throwError are operators.
              ......
              return throwError(errorResponse);  ## returns an observable.
            })
          )).subscribe(
            ....
          );
        }
      </pre>
      <p>We may need to add custom headers with our request. We can do it as follows,</p>
      <pre>
        this.http.get(
          url,
          {
            headers: new HttpHeaders({
              'key': value
            })
          }
        )
      </pre>
      <p>Sometimes api may support query params. In that case we can either send params with the url or we can do it as follows,</p>
      <pre>
        let searchParams = HttpParams();
        searchParams = searchParams.append('key1','value1');
        searchParams = searchParams.append('key2','value2');

        this.http.get(
          url,
          {
            headers: ....,
            params: searchParams     ## The url will be converted into, url?key1=value1&key2=value2
          }
        )
      </pre>
      <p>So far the response we get is actually the response body parsed by Angular. But we can also get the full response object.</p>
      <pre>
        this.http.get(
          url,
          {
            ....
            observe: 'response'   ## By default, it is set to 'body'. There is also 'events' that we can use.
          }
        )
      </pre>
      <p>Similarly, we can also define responseType and set it to 'json', 'text', 'blob' etc.</p>
      <p>
        So far whenever we are configuring headers or params etc, we are doing this in every request. Suppose we have to 
        add same configurtaion in every outgoing request (for example, authentication header). Instead of repeating ourselves 
        we can use <span>interceptor</span> (a type of service). Inside auth-interceptor.service.ts file,
      </p>
      <pre>
        export class AuthInterceptorService implements HttpInterceptor {
          ## below method will be run right before the request leaves the application.
          intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
            ## req object is immutable. Thus we have to clone it and modify.
            const modifiedRequest = req.clone({
              headers: req.headers.append('Auth', '987328-Ade-2321')
            });
            return next.handle(modifiedRequest);
          }
        }
      </pre>
      <p>
        We have to provide this service in a special way so that Angular will automatically inject the service and run it when a 
        request leaves the application. In app.module.ts file,
      </p>
      <pre>
        import { HTTP_INTERCEPTORS } from '@angular/common/http';
        @NgModule({
          .....
          providers: [{provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true}]
        })
      </pre>
      <p>We can also interact with the response inside an interceptor.</p>
      <pre>
        export class AuthInterceptorService implements HttpInterceptor {
          intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
            ........
            return next.handle(modifiedRequest).pipe(.....);  ## Here response type will always be an event.
          }
        }
      </pre>
      <p>We can add multiple interceptors and they will be run according to their order inside the providers array.</p>
      <pre>
        @NgModule({
          .....
          providers: [
            {provide: HTTP_INTERCEPTORS, useClass: FirstInterceptorService, multi: true},
            {provide: HTTP_INTERCEPTORS, useClass: SecondInterceptorService, multi: true}
          ]
        })
      </pre>
    </section>
    <section>
      <h2>Authetication & Route Protection</h2>
      <p></p>
      <pre></pre>
    </section>

    <section>
      <h2></h2>
      <p></p>
      <pre></pre>
    </section>
  </main>
</body>
</html>