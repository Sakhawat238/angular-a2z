<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Angular A2Z</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <main class="container">
    <section>
      <h2>Set Up</h2>  
      <pre>
        npm install -g @angular/cli@latest
        ng new app-name
        cd app-name
        ng serve
      </pre> 
    </section>
    <section>
      <h2>Adding Module</h2>
      <p>If we want to add any module in our application, we have to include it in our app.module.ts file.</p>
      <pre>
        import { module-name } from 'source-name'
        @NgModule({
          ......,
          imports:[
            ......,
            module-name
          ],
          ....
        })
      </pre>
    </section>
    <section>
      <h2>Kick Start</h2>
      <p>In 'main.ts' file we define which module to start first.</p>
      <pre>
        platformBrowserDynamic().bootstrapModule(AppModule)
      </pre>
      <p>In 'app.module.ts' file we tell which component is the root compoenent.</p>
      <pre>
        @NgModule({
          ......,
          bootstrap:[AppComponent],
          ....
        })
      </pre>
      <p>In 'app.component.ts' file we define component selector tag.</p>
      <p>Angular serves 'index.html' file which contains app component tag.</p>
      </div>
    </section>
    <section>
      <h2>Component</h2>
      <p>Component selector is used to tell Angular to consider a class as a component.</p>
      <p>It contains all necessary information regarding that component.</p>
      <pre>
        @Component({
          selector: 'tag-name',  ##used in html code to represent this component
          templateUrl: 'html-file-path',
          styleUrls: [...list of stylesheet files]
        })
      </pre>
      <p>TemplateUrl or template is a required attribute. But we can skip selector, styleUrls etc.</p>
      <p>To Register a component, add the component class name inside declaration array of NgModule decorator in app.module.ts file.</p>
      <p>Component creation shortcut : <span>ng g c 'component-name'</span></p>
      <p>Three ways to use component selector :</p>
      <p>1. We declare selector: 'tag-name' and use it as, <span>&lt;tag-name&gt;&lt;/tag-name&gt;</span></p>
      <p>2. We declare selector: '[tag-name]' and use it as attribute, <span>&lt;div tag-name&gt;&lt;/div&gt;</span></p>
      <p>3. We declare selector: '.tag-name' and use it as class, <span>&lt;div class="tag-name"&gt;&lt;/div&gt;</span></p>
      </div>
    </section>
    <section>
      <h2>String Interpolation</h2>
      <p>String interpolation: <span>{{data}}</span></p>
      <p>Here data can be anything as long as it generates a string.</p>
      <p>So data can be variable from .ts file, or function or expression.</p>
      <p>But we cannot write multi line expression here.</p>
      <p>We can not use if else block; but we can use ternary expression.</p>
      </div>
    </section>
    <section>
      <h2>Property Binding</h2>
      <p>Property binding: <span>[property]="data"</span></p>
      <p>Here data can be anything as long as it generates a proper value for that property.</p>
      <p>We can sometimes replace string interpolation with property binding, for example:</p>
      <p>In .ts file,</p>
      <pre>
        title = 'Hello World!';
      </pre>
      <p>In .html file,</p>
      <pre>
        &lt;p&gt;{{title}}&lt;/p&gt;
        &lt;p [innerText]="title"&gt;&lt;/p&gt;
      </pre>
      </div>
    </section>
    <section>
      <h2>Event Binding</h2>
      <p>Event binding: <span>(event)="expression"</span></p>
      <pre>
        (click)="addNewUser()"
        (input)="updateUsername($event)"  ## Here $event refers to the value that input event emits
      </pre>
      </div>
    </section>
    <section>
      <h2>Two way Binding</h2>
      <p>Two way binding: <span>[(ngModel)]="data"</span></p>
      <pre>
        username = "";                              ## In .ts file
        &lt;input type="text" [(ngModel)]="username"&gt;  ## In .html file
      </pre>
      <p>Now if input changes, value of username will change too. Also if value of username changes, value of input field will change too.</p>
      </div>
    </section>
    <section>
      <h2>Directive</h2>
      <p>Directives are instructions in the DOM.</p>
      <p>Components are kind of such instructions in the DOM.</p>
      <p>Once we place the selector of our component somewhere in our templates, we're in
        structing Angular to add the content of our component template and the business logic in our TypeScript code in this place where we use the selector.
      </p>
      <p>Indeed components are directives but directives with a template, there are also directives without a template.</p>
      <p>For example, <span>*ngIf</span> is a structural directive that changes the structure of the dom.</p>
      <p><span>ngStyle</span>, <span>ngClass</span> are attribute directives, without a * before. They just modify element.</p>
      <p>Some directive take static value like true or false whereas some take js object.</p>
      </div>
    </section>
    <section>
      <h2>ngStyle</h2>
      <pre>
        &lt;p [ngStyle]="{backgroundColor: getColor()}"&gt;Hello World&lt;/p&gt;
        &lt;p [ngStyle]="{'background-color': status == true ? 'green' : 'red'}"&gt;Hello World&lt;/p&gt;
      </pre>
      <p>So it works like a attribute, thus we can use property binding on it.</p>
      <p>It allows us to dynamically add or remove css styles.</p>
      <p>It takes an object; key value pair, where key is a css property, value can be anything.</p>
      </div>
    </section>
    <section>
      <h2>ngClass</h2>
      <pre>
        &lt;p [ngClass]="{'active': getStatus()}"&gt;Hello World&lt;/p&gt;
      </pre>
      <p>So it works like a attribute, thus we can use property binding on it.</p>
      <p>It allows us to dynamically add or remove css class.</p>
      <p>It takes an object; key value pair, where key is a class name, value can be anything that returns true or false.</p>
      </div>
    </section>
    <section>
      <h2>If Else</h2>
      <pre>
        &lt;p *ngIf="isVisible; else elseblock">You are visible now&lt;/p&gt;
        &lt;ng-template #elseblock&gt;
          &lt;p&gt;You are invisible&lt;/p&gt;
        &lt;/ng-template&gt;
      </pre>
      </div>
    </section>
    <section>
      <h2>For Loop</h2>
      <pre>
        &lt;p *ngFor="let item of items, let i = index"&gt;{{i}}. Hi {{item}}&lt;/p&gt;
      </pre>
      </div>
    </section>
    <section>
      <h2>Switch Case</h2>
      <pre>
        &lt;div [ngSwitch]="value"&gt;
          &lt;p *ngSwitchCase="1"&gt;Value is 1&lt;/p&gt;
          &lt;p *ngSwitchCase="2"&gt;Value is 2&lt;/p&gt;
          &lt;p *ngSwitchCase="3"&gt;Value is 3&lt;/p&gt;
          &lt;p *ngSwitchDefault&gt;Value is default&lt;/p&gt;
        &lt;/div&gt;
      </pre>
      </div>
    </section>
    <section>
      <h2>Passing data to child component</h2>
      <p>We will use property binding.</p>
      <p>We will use <span>Input()</span> decorator.</p>
      <p>In parent.ts file,</p>
      <pre>
        serverElements = [{os:'linux', version:'ubuntu'}, {os:'windows', version:'10'}]
      </pre>
      <p>In parent.html file,</p>
      <pre>
        &lt;app-child *ngFor="se of serverElements" [server]="se"&gt;&lt;/app-child&gt;
      </pre>
      <p>In child.ts file,</p>
      <pre>
        @Input() server : {os:string, version:string};
      </pre>
      <p>In child.html file,</p>
      <pre>
        &lt;p&gt;{{server.os}} {{server.version}}&lt;/p&gt;
      </pre>
      <p>We can bind throuh alias, instead of using direct property name.</p>
      <pre>
        @Input("alias name"), then in parent html file ["alias name"]="data".
      </pre>
      </div>
    </section>
    <section>
      <h2>Listening event from child component</h2>
      <p>We will use event binding.</p>
      <p>We will use <span>EventEmitter&lt;&gt;()</span> class and <span>Output()</span> decorator.</p>
      <p>In child.html file,</p>
      <pre>
        &lt;button (click)="onAddServer()"&gt;&lt;/button&gt;
      </pre>
      <p>In child.ts file,</p>
      <pre>
        serverOS = ''     ## Two way binded with input field
        serverVersion = ' '     ## Two way binded with input field
        @Output() serverAdded = new EventEmitter&lt;{os: string, version:string}&gt;()
        onAddServer(){
          this.serverAdded.emit({os: serverOS, version: serverVersion})
        }
      </pre>
      <p>In parent.html file,</p>
      <pre>
        &lt;app-child (serverAdded)="onServerAdded($event)"&gt;&lt;/app-child&gt;
      </pre>
      <p>In parent.ts file,</p>
      <pre>
        onServerAdded(serverdata:{os: string, version:string}){
          do something
        }
      </pre>
      <p>We can bind throuh alias, instead of using direct event name.</p>
      <pre>
        @Output("alias name"), then in parent html file ("alias name")="data".
      </pre>
      </div>
    </section>
    <section>
      <h2>Style Encapsulation</h2>
      <p>Lets say, parent component has a style, p{color:blue}.</p>
      <p>Now this style will only apply to the components that are inside app component html file.</p>
      <p>It wont apply to any of its child component, though they are inside app component.</p>
      <p>This is called view encapsulation.</p>
      <p>Angular does that by assiging each element inside the component a unique and same attribute.</p>
      <p>Then Angular changed the above style to, p[attribute_name]{color:blue}</p>
      <p>We can override this behavior by adding a property in component decorator.</p>
      <pre>
        @Component({
          .........
          encapsulation: ViewEncasulation.None  ## Disable adding attribute, thus no encapsulation.
          encapsulation: ViewEncasulation.Native ## Apply shadow dom technique if browser supports.
          encapsulation: ViewEncasulation.Emulated ## Default, encapsulation enabled.
        })
      </pre>
      </div>
    </section>
    <section>
      <h2>Template Reference</h2>
      <p>In general, we two way bind input field with typescript variable, so that we can capture user input.</p>
      <p>But this process update variable for every input change.</p>
      <p>Instead of updating varible for every input, we can use template reference to get input data when needed.</p>
      <p>In html file,</p>
      <pre>
        &lt;input type="text" #nameInput&gt;  ## We are adding a reference to this input field.
        &lt;button (click)="onAddName(nameInput)"&gt;&lt;/button&gt;
      </pre>
      <p>We can directly use this reference in html file only, not in ts file.</p>
      <p>So we pass this as an argument of onAddName() method to use it inside ts file.</p>
      <p>Here #nameInput refers to the whole input element.</p>
      <p>In ts file,</p>
      <pre>
        onAddName(inputdata : HTMLInputElement){
          console.log(inputdata.value)  ## We can use this value now.
        }
      </pre>
      <p>There is another way to access any html element from typescript without passing them through method.</p>
      <p>In html file,</p>
      <pre>
        &lt;input type="text" #nameInput&gt;
        &lt;button (click)="onAddName()"&gt;&lt;/button&gt;  ## We no longer pass the reference.
      </pre>
      <p>In ts file,</p>
      <pre>
        @ViewChild('nameInput',{static:true/false}) nameData : ElementRef
        onAddName(){
          console.log(this.nameData.nativeElement.value)
        }
      </pre>
      <p>Here nameData refers to html element and to get that element, we use nativeElement property.</p>
      <p>
        { static: true } as a second argument needs to be applied to all usages of @ViewChild() (and also @ContentChild() discussed later)
        if we plan on accessing the selected element inside of ngOnInit(). If we don't access the selected element in ngOnInit 
        (but anywhere else in our component), we will set static: false instead! This is a temporary adjustment which will not be 
        required anymore once Angular 9 is released!
      </p>
      </div>
    </section>
    <section>
      <h2>Html Code Inject</h2>
      <p>Let say we have a component named test component with selector &lt;app-test&gt;</p>
      <p>Inside parent component,</p>
      <pre>
        &lt;app-test&gt;...Any html code or anything thing we write here would not be rendered by angular...&lt;/app-test&gt;
      </pre>
      <p>But we can use <span>ng-content</span> to render html.</p>
      <p>Inside test component html file,</p>
      <pre>
        &lt;div&gt;
          &lt;h1&gt;Hello world&lt;/h1&gt;
          &lt;ng-content&gt;&lt;/ng-content&gt;
        &lt;/div&gt;
      </pre>
      <p>Now whatever we write between &lt;app-test&gt; ... &lt;/app-test&gt; will replace &lt;ng-content&gt;&lt;/ng-content&gt;</p>
      <p>Previously, We use @ViewChild() to access referenced element of a component's own template.</p>
      <p>But if the html code is projected via ng-content, thus any refernce in that code can be access from parent compoent.</p>
      <p>To access this reference from child component, we have to use <span>@ContentChild()</span>.</p>
      <p>Inside parent component html file,</p>
      <pre>
        &lt;app-test&gt;&lt;p #demo&gt;Hello&lt;/p&gt;&lt;/app-test&gt;
      </pre>
      <p>In test component ts file,</p>
      <pre>
        @ContentChild('demo',{static:true/false}) demoref: ElementRef
      </pre>
      </div>
    </section>
    <section>
      <h2>Component Lifecycle</h2>
      <p><span>Constructor</span>: called first.</p>
      <p>
        <span>ngOnChanges</span>: can be executed multiple times; executed right at the start when new component is created.
        Also called whenever our bound input property changes, that means @Input() decorated property receives new value. 
        Only method that receives argument: ngOnChanges(changes: SimpleChanges).
      </p>
      <p><span>ngOninit</span>: executed once the component is initialized but not displayed yet.</p>
      <p>
        <span>ngDoCheck</span>: can be executed multiple times; called during every change detection run. 
        Angular check the dom for various reason, and everytime angular check, this method will also run.
      </p>
      <p><span>ngAfterContentInit</span>: called after ng-content has been projected into view.</p>
      <p><span>ngAfterContentChecked</span>: called everytime the projected content has been checked.</p>
      <p>
        <span>ngAfterViewInit</span>: called after the component's view (and child views) has been initialized. Now 
        we can access template and reference template element.
      </p>
      <p><span>ngAfterViewChecked</span>: called every time the component's view (and child views) has been checked.</p>
      <p><span>ngOnDestroy</span>: called once the component is about to destroy.</p>
      </div>
    </section>
    <section>
      <h2>Directive Advanced</h2>
      <p>Mainly two types: Attribute and Structural.</p>
      <p>Can not have more than one structural directive in the same element.</p>
      <p>So we can not use *ngIf and *ngFor together on same element, But we can use structural and attribute (multiple) directive together.</p>
      <p>We can create custom directive. For example,</p>
      <p>In demo.directive.ts file,</p>
      <pre>
        @Directive({
          selector: '[appDemo]'  ## Here we are using attribute styled selector and camel case format.
        })
        export class DemoDirective implements OnInit {
          constructor(private elementRef: ElementRef){}  ## Here elementRef refers to the element where our directive has been placed on.
          ngOnInit(){
            this.elementRef.nativeElement.backgroundColor = 'White'; 
          }
        }
      </pre>
      <p>Then in app.module.ts file we add,</p>
      <pre>
        @NgModule({
          declarations : [....., DemoDirective,...]
        })
      </pre>
      <p>Now we can use it on any component or element, like this,</p>
      <pre>
        &lt;p appDemo&gt;This is styled by demo directive&lt;/p&gt;
      </pre>
      <p>But accessing and then directly modifying element via ElementRef is not a good practice.</p>
      <p>Rather we can use <span>Renderer2</span>.</p>
      <pre>
        constructor(private elementRef: ElementRef, private renderer: Renderer2){}
        ngOnInit(){
          this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'green', 'optional-fourth-argument');
        }
      </pre>
      <p>We can also listen event from the element and write logics on directive based on the events.</p>
      <pre>
        @HostListener('mouseenter') mouseover(evendata: Event) {
          this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'green', 'optional-fourth-argument');
        }
      </pre>
      <p>
        Here mouseenter is a html event and when mouse enter on host element, this event emits. Directive listen to this event 
        and call mouseover method, thus changing host element background style.
      </p>
      <p>There is a shortcut to change host element style rather than using elementRef and renderer.</p>
      <pre>
        @HostBinding('style.backgroundColor') bgColor : String;
        ngOnInit(){
          this.bgColor = 'Red';
        }
      </pre>
      <p>Using hostbinding we can access properties of the element.</p>
      <p>Here we are defining background color by ourselves but we can make it dynamic.</p>
      <p>We can use the concept of property binding.</p>
      <p>In demo.directive.ts file,</p>
      <pre>
        @Input() color : String = 'red'
        @HostBinding('style.backgroundColor') bgColor : String;
        ngOnInit(){
          this.bgColor = this.color;
        }
      </pre>
      <p>In any component html file,</p>
      <pre>
        &lt;p appDemo [color]="'green'"&gt;This will be colored green&lt;/p&gt;
      </pre>
      <p>Here appDemo is the directive and color is it's property</p>
      <p>Angular can determine which property comes from directive and which property comes from component itself.</p>
      <p>Suppose, color is the only property of this decorator. Then we can alias it in directive selector name.</p>
      <pre>
        @Input('appDemo') color : String = 'red'
      </pre>
      <p>Then in html file we can write,</p>
      <pre>
        &lt;p [appDemo]="green"&gt;This will be colored green&lt;/p&gt;
      </pre>
      <p>This is what happened with [ngClass] and [ngStyle] directive.</p>
      <p>Lets discuss about structural directive.</p>
      <p> We use * before structural directive but behind the scene it converts into something else.</p>
      <pre>
        &lt;div *ngIf=""&gt;....&lt;/div&gt;
      </pre>
      <p>But it converts to our familiar property binding.</p>
      <pre>
        &lt;ng-template [ngIf]=""&gt;
          &lt;div&gt;...&lt;/div&gt;
        &lt;/ng-template&gt;
      </pre>
      <p>Lets create a structural directive that works exactly opposite of ngIf.</p>
      <pre>
        @Directive({
          selector: 'appUnless'
        })
        @Input('appUnless') set unless(condition: boolean) {
          if(!condition) {
            this.vcRef.createEmbeddedView(this.templateRef);
          } else {
            this.vcRef.clear();
          }
        }
        ## This a shortcut. Here unless is a property and we define a setter for it.
        ## Thus when unless propety changes from outside, the above method will be called.
        constructor(private templateRef: TemplateRef&lt;any&gt;, private vcRef: ViewContainerRef){
          ## Here we use TemplateRef to get refernce of ng-template; This is 'what' we will render.
          ## We use ViewContainerRef to get refernce to 'where' we will render it.
        }
      </pre>
      <p>Now in component file,</p>
      <pre>
        &lt;div *appunless=""&gt;....&lt;/div&gt;
      </pre>
      <p>Shortcut for creating directive: <span>ng g d 'name'</span></p>
      </div>
    </section>
    <section>
      <h2>Service</h2>
      <p>Simple typescript class without any decorator like @Component() or @Directive().</p>
      <p>Holds some fucntionallity and methods that will be used in various components.</p>
      <p>In demo.service.ts,</p>
      <pre>
        export class DemoService {
          doSomething(arg){
            console.log(arg);
          }
        }
      </pre>
      <p>In general, we can simply import the class, create an instance and call the methods.</p>
      <p>For example, In any.component.ts file,</p>
      <pre>
        import { DemoService } from ......
        ds = new DemoService();
        ds.doSomething("hi");
      </pre>
      <p>But thats not the best practice. Rather we let Angular create the instance for us.</p>
      <p>In any.component.ts file,</p>
      <pre>
        constructor(private ds : DemoService){}
        this.ds.doSomething("hi");
      </pre>
      <p>
        Here, by adding a variable with type Demoservice in the constructor, we tell Angular to provide 
        us an instance of Demoservice when Angular creates the component.
      </p>
      <p>But that alone is not enough. Because now Angular knows what you need but it does not know how to
        get it. So we have to add the following line inside @Component() decorator.</p>
      <pre>
        @Component({
          .....
          providers: [DemoService]
        })
      </pre>
      <p>This tells Angular who will provide the instance.</p>
      <p>Lets say we have two components from two different component tree.</p>
      <p>If we use a service in both of them in the above method, Angular will provide two different instance for them.</p>
      <p>Now if the service has some data storage like array or variables, updating them in one of the component's service won't affect the other. </p>
      <p>This behavior of Angular is called Hierarchial Injector.</p>
      <p>
        If we inject a service in a component, that component and all of its children will receive the exact 
        same instance of that service. Any other component will not have any access to that instance of the service.
      </p>
      <p>So we can inject a service in the AppModule to make one common instance accessible for every components and services in the app.</p>
      <p>Lets say, app component has two child components: abc & xyz.</p>
      <p>To provide same instance of DemoService to both of them, we add DemoService in the providers array of app component.</p>
      <p>
        Then in abc and xyz component we no longer add this service in their providers array. If we do, then Angular will
        create seperate instance for each of these components.
      </p>
      <p>But we have to declare a variable of DemoService in constructor of both of them like before.</p>
      <p>We can inject a service into another service and the procedure is almost same as before.</p>
      <p>But service doesnot have any metadata (stored in decorators i.e @Component()) like component and directive does.</p>
      <p>So we have to add <span>@Injectable()</span> on top of the second service class where we are injecting the first service.</p>
      <pre>
        @Injectable()
        export class DemoService2 (){
          constructor(private ds:DemoService){}
        }
      </pre>
      <p>We can also provide application-wide services in a different way.</p>
      <p>Instead of adding a service class to the providers[] array in AppModule, we can set the following config in the service itself,</p>
      <pre>
        @Injectable({providedIn: 'root'})
        export class MyService { ... }
      </pre>
      <p>Using this new syntax is completely optional, the traditional syntax (using providers[] ) will still work.</p>
      <p>
        The "new syntax" does offer one advantage though: Services can be loaded lazily by Angular (behind the scenes) 
        and redundant code can be removed automatically.
      </p>
    </div>
    </section>
    <section>
      <h2>Routing</h2>
      <p>Suppose, app comonent has tree child component: home, student, teacher.</p>
      <p>In app.component.html file,</p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Teacher&lt;/a&gt;
        &lt;/div&gt;
        &lt;app-home&gt;&lt;/app-home&gt;
        &lt;app-student&gt;&lt;/app-student&gt;
        &lt;app-teacher&gt;&lt;/app-teacher&gt;
      </pre>
      <p>
        Here these components are shown together but we want to show them individually whenever we click corresponding
        link. We can solve this using routing.
      </p>
      <p>In app.module.ts file,</p>
      <pre>
        import { Routers, RouterModule } from '@angular/router';
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent },
          { path: 'teachers', component: TeacherComponent }
        ]
        @NgModule({
          imports: [
            ......
            RouterModule.forRoot(appRoutes)
          ]
        })
      </pre>
      <p>Now in app.component.html file,</p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a href="#"&gt;Teacher&lt;/a&gt;
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;  ## router-outlet is a directive, not a component.
      </pre>
      <p>
        Now we can visit each component individually by browsing their urls. But we still cannot change url by clicking the links yet. 
        We can do the followings,
      </p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a href="/"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a href="/students"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a href="/teachers"&gt;Teacher&lt;/a&gt;
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;
      </pre>
      <p>
        Now we can click on any link and it will take us to corresponding component. But this method is not ok because it will
        reload/restart the whole app. Thus we may lose current state of the app and many other things. So this is not how we will
        navigate in our app.
      </p>
      <p>Instead of using href we can use <span>routerLink</span></p>
      <pre>
        &lt;div&gt;
          &lt;li class="active"&gt;&lt;a routerLink="/"&gt;Home&lt;/a&gt;
          &lt;li&gt;&lt;a routerLink="/students"&gt;Student&lt;/a&gt;
          &lt;li&gt;&lt;a [routerLink]="['/teachers']"&gt;Teacher&lt;/a&gt;  ## We can use property binding.
        &lt;/div&gt;
        &lt;router-outlet&gt;&lt;/router-outlet&gt;
      </pre>
      <p>
        Note that, we have used '/' as a prefix in 'students' and 'teachers'. If we use 'students' instead of '/students', Angular will
        treat it as a relative path. For example, if we have a button in student component with routerLink="students", then Angular will
        think it as 'localhost:4200/students/students'. Similarly, './students' will generate same url. But we can use '../students' for
        'localhost:4200/students'. That is, we go up one level, then add 'students' to url. Thus we can use '../../students' if needed.
      </p>
      <p>
        Right now we get no visual indication of what the currently active route is. Home component selector has class="active" in it. 
        It would be nice if we can add or remove this class on each element dynamically.
      </p>
      <p>
        For that we will use <span>routerLinkActive</span> directive provided by Angular. It will apply any css class provided
        by us to the element if it is currently the active element. 
      </p>
      <pre>
        &lt;li routerLinkActive="active"&gt;&lt;a routerLink="/"&gt;Home&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a routerLink="/students"&gt;Student&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a [routerLink]="['/teachers']"&gt;Teacher&lt;/a&gt;
      </pre>
      <p>
        Now whenever we click on a link, active class will be applied to it. But problem is, home component url is always
        active becuase routerLinkActive matches paths and home compoent path '/' exists in all other compoent paths. SO we have to
        check if path is exactly matched. So we can add special configurtaion on our routerLinkActive directive.
      </p>
      <pre>
        &lt;li routerLinkActive="active" [routerLinkActiveOptions]="{exact:true}"&gt;&lt;a routerLink="/"&gt;Home&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a routerLink="/students"&gt;Student&lt;/a&gt;
        &lt;li routerLinkActive="active"&gt;&lt;a [routerLink]="['/teachers']"&gt;Teacher&lt;/a&gt;
      </pre>
      <p>So far we have loaded route via link. But we can also navigate from a function</p>
      <pre>
        constructor(private router:Router){}
        onLoadStudents(){
          this.router.navigate(['/students']);
        }
      </pre>
      <p>
        Now if we use relative path inside navigate() i.e if we use 'students' instead of '/students', it will work same. Previously we
        have used this approach and it would create this url, 'localhost:4200/students/students' but unlike the routerLink, navigate method 
        does not know on which route we are currently on. So it will start from 'localhost:4200'. But we can tell it our current route
        by passing a second argument inside navigate(). 
      </p>
      <pre>
        constructor(private router:Router, private route:ActivatedRoute){}
        onLoadUser(){
          this.router.navigate(['/students'], {relativeTo:this.route});
        }
      </pre>
      <p>We can add parameter to our routes to generate urls for dynamic components.</p>
      <p>In app.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students/:id/:name', component: StudentDetailsComponent },
          .......
        ]
      </pre>
      <p>In studentdetails.component.ts file,</p>
      <pre>
        student : {id:number, name:string};
        constructor(private route:ActivatedRoute){}
        ngOnInit(){
          this.student = {
            id : this.route.snapshot.params['id'],  ## id will be a string, so we may need to convert it into number.
            name : this.route.snapshot.params['name']
          }; 
        }
      </pre>
      <p>In studentdetails.component.html file,</p>
      <pre>
        {{ student.id}} {{ student.name }}
      </pre>
      <p>Now we can visit 'localhost:4200/students/1/john' from the browser. It will render StudentDetailsComponent with given id and name.</p>
      <p>Lets add the following codes inside studentdetails.component.html file,</p>
      <pre>
        {{ student.id}} {{ student.name }}
        &lt;a [routerLink]="['/students',2,'Alex']"&gt;Check Alex&lt;/a&gt;  ## localhost:4200/students/2/Alex
      </pre>
      <p>
        If we click on 'Check Alex', we see that the url on the browser has changed to the one we have expected but the component did not change. 
        This is not a bug, rather the default behavior of Angular. We are currently on StudentDetailsComponent and we are trying to visit StudentDetailsComponent
        again. Thus Angular won't re-render the component. Though we are passing new data, Angular does not know that. To tell Angular to re-render
        this component with new data, we add the following codes inside studentdetails.component.ts file,
      </p>
      <pre>
        ngOnInit(){
          this.student = {
            id : +this.route.snapshot.params['id'],      ## add '+' to convert string to number.
            name : this.route.snapshot.params['name']
          }; 
          ## route.params is an observable.
          this.route.params.subscribe( (prms:Params) => {
            this.student.id = +prms['id'];
            this.student.name = prms['name'];
          })
        }
      </pre>
      <p>
        We can also pass query parameters and fragments with our url (localhost:4200/teachers/2?age=55&nid=12345#editing) 
        and somehow we have to retrieve these informations. To show how to do this, first we add another route in app.module.ts file,
      </p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'teachers/:id/edit', component:EditTeacherComponent },
          .......
        ]
      </pre>
      <p>Now in teacher.component.html file,</p>
      <pre>
        &lt;a 
          [routerLink]="['/teachers', 2, 'edit']"  ## [routerLink]="['/teachers', teacher.id, 'edit']"
          *ngFor="let teacher of teachers"
        &gt;{{ teacher.name }}&lt;/a&gt;
      </pre>
      <p>
        Suppose we want to add a query parameter 'allowEdit' which will determine the permission of editing. Instead of adding it inside the array,
        we will use property binding.
      </p>
      <pre>
        &lt;a 
          [routerLink]="['/teachers', 2, 'edit']" 
          [queryParams]="{ allowEdit:'1'}"  ## Not a directive, rather a property of routerLink directive.
          *ngFor="let teacher of teachers"
        &gt;{{ teacher.name }}&lt;/a&gt;
      </pre>
      <p>Clicking on the link will now generate the follwing url, localhost:4200/teachers/2/edit?allowEdit=1. We can also add fragment,</p>
      <pre>
        &lt;a 
          [routerLink]="['/teachers', 2, 'edit']" 
          [queryParams]="{ allowEdit:'1'}" 
          [fragment]="'loading'"
          *ngFor="let teacher of teachers"
        &gt;{{ teacher.name }}&lt;/a&gt;
      </pre>
      <p>Now the generated url is, localhost:4200/teachers/2/edit?allowEdit=1#loading</p>
      <p>We can also do the samething inside function.</p>
      <pre>
        constructor(private router:Router){}
        onLoadTeacher(id:number){
          this.router.navigate(['/teachers', id, 'edit'], {queryParams: {allowEdit:'1'}, fragment: 'loading'});
        }
      </pre>
      <p>Now we will see how to retrieve this information.</p>
      <pre>
        constructor(route:ActivatedRoute){}
        ngOnInit(){
          console.log(this.route.snapshot.queryParams);
          console.log(this.route.snapshot.fragment);
        }
      </pre>
      <p>Now this approach will create the same re-rendering problem. So like params, we can also subscribe to queryParams and fragment.</p>
      <pre>
        constructor(route:ActivatedRoute){}
        ngOnInit(){
          .......
          this.route.queryParams.subscribe();
          this.route.fragment.subscribe();
        }
      </pre>
      <p>Lets discuss about child routing. Suppose we have the following routes,</p>
      <pre>
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent },
          { path: 'students/:id', component: StudentDetailsComponent},
          { path: 'students/:id/edit', component: EditStudentComponent},
          { path: 'teachers', component: TeacherComponent },
          { path: 'teachers/:id', component: TeacherDetailsComponent }
        ]
      </pre>
      <p>We can rewrite these as follows,</p>
      <pre>
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]},
          { path: 'teachers', component: TeacherComponent, children: [
            { path: ':id', component: TeacherDetailsComponent}
          ]}
        ]
      </pre>
      <p>
        Now we can only render top level component inside router-outlet of app-component. So child routes of student component
        need seperate router-outlet inside student component html file. 
      </p>
      <p>
        Suppose we want to pass query params from one link to another. For example, student compnent has some query params in its url 
        and we want these to carry forward to student edit component url. In that case, we configue as follows,
      </p>
      <pre>
        constructor(private router:Router, private route:ActivatedRoute){}
        onEditStudent(id:number){
          this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'reserve/merge'});
          ## reserve -> when we do not add any new query params.
          ## merge -> when we add more new query params.
        }
      </pre>
      <p>What will happen when someone tries to visit a page that doesnot exists? We may show 404 message or simply redirect them to another page.</p>
      <p>Lets start with redirecting.</p> 
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'not-found', component: PageNotFoundComponent },
          { path: '**', redirectTo: '/not-found'}  ## wildcard routing; catch all unseen urls; so it must be last path in this array.
        ]
      </pre>
      <p>In general if we have more than 2 or 3 routes, it is better to define them in a seperate module.</p>
      <p>In app-routing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          { path: '', component: HomeComponent },
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]},
          { path: 'teachers', component: TeacherComponent, children: [
            { path: ':id', component: TeacherDetailsComponent}
          ]}
        ]

        @NgModule({
          imports: [
            RouterModule.forRoot(appRoutes)  ## We configured routermodule.
          ],
          exports: [
            RouterModule    ## Now, we export it for app module.
          ]
        })
        export class AppRoutingModule {
        }
      </pre>
      <p>
        Now we simply add AppRoutingModule in the imports array of app module. Note that, ordering is important while working with dynamic route. 
        Lets say, we want to add url 'students/new'. If we add this 'new' path after ':id' path in the children array, Angular will think 'new' as 
        a param. So fixed url patterns must be declared before dynamic patterns.
      </p>
      <p>
        Lets discuss about route guards: functionallity, logic, code which is executed when a route is loaded or when we leave a route. 
        We may want to prevent a user from accessing certain routes. We can write code inside ngOnInit of each component but that is totally
        inefficient. Rather we can use <span>canActivate</span> provided by Angular.
      </p>
      <p>Lets create a service which will works as a fake auth service. Inside auth.service.ts file,</p>
      <pre>
        export class AuthService {
          loggedIn = false;

          isAuthenticated() {
            const promise = new Promise(
              (resolve, reject) => {
                setTimeout(() =>{              ## mimicking a server call which will take some time.
                  resolve(this.loggedIn);
                }, 8000)
              }
            );
            return promise;
          }

          login() {
            this.loggedIn = true;
          }

          logout() {
            this.loggedIn = false;
          }
        }
      </pre>
      <p>Now we create a service named auth-guard. Inside auth-guard.service.ts file,</p>
      <pre>
        import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';
        import { Observable } from 'rxjs/Observable';
        import { Injectable } from '@angular/core';
        import { AuthService } from './auth.service';

        @Injectable()
        export class AuthGuard implements CanActivate {
          constructor(private authService: AuthService, private router: Router){}

          canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
            Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            return this.authService.isAuthenticated().then(
              (authenticated: boolean) => {
                if (authenticated) {
                  return true;
                } else {
                  this.route.navigate(['/']);
                }
              }
            );
          }
        }
      </pre>
      <p>Our guard is ready. Suppose we want to apply this guard in student component route. Inside app-rotuing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', canActivate: [AuthGuard],  component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]}
        ]
      </pre>
      <p>Here authguard will be applied to student component route and all of its child routes. We can add multiple guard.</p>
      <p>
        Suppose we want to access student component freely but put restriction on it's child components. For that we can put 
        canActivate on child components but there is a better approach for that. We have to implement <span>CanActivateChild</span>.
      </p>
      <pre>
        @Injectable()
        export class AuthGuard implements CanActivate, CanActivateChild {
          constructor(private authService: AuthService, private router: Router){}

          canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
            Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            ........
          }

          CanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
            Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            return this.canActivate(route, state);
          }
        }
      </pre>
      <p>Now apply this on student component route.</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', CanActivateChild: [AuthGuard],  component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent}
          ]}
        ]
      </pre>
      <p>Now we will control whether a user can leave a route.</p>
      <p>For example, we may ask the user to confirm before leaving the student edit page.</p>
      <p>In edit-student.component.ts file,</p>
      <pre>
        changesSaved = false;

        onUpdateStudent() {
          .......
          this.changesSaved = true;
          this.router.navigate(['../'], {relativeTo: this.route});
        }
      </pre>
      <p>
        So we check the state of 'changesSaved' and decide whether a user can leave the route or not. To prevent leaving, 
        we have to execute some logic inside student edit component. But route guard is usually of type service becuase we will
        provide it in the routing module. So somehow we need to access the code in our edit component and also have a service. Though 
        it seems to be a complex task, we can handle it as follows,
      </p>
      <p>Lets add a service named can-deactivate-guard. Inside can-deactivate-guard.service.ts file,</p>
      <pre>
        import { CanDeactivate } from '@angular/router';
        import { Observable } from 'rxjs/Observable'

        export interface CanComponentDeactivate {
          canDeactivate: () => Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;
        }

        export class canDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt;{
          ## This method will be called by Angular whenever user try to leave the route.
          canDeactivate(component: CanComponentDeactivate, 
                        currentroute: ActivatedRouteSnapshot, 
                        currentstate: RouterStateSnapshot,
                        nextState?: RouterStateSnapshot):       ## '?' means optional parameter.
                        Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            return component.canDeactivate();
          }
        }
      </pre>
      <p>Now inside app-routing module,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent},
            { path: ':id/edit', component: EditStudentComponent, canDeactivate: [canDeactivateGuard]}
          ]}
        ]
      </pre>
      <p>Now we have to implement CanComponentDeactivate in student edit component.</p>
      <pre>
        export class EditStudentComponent implements Oninit, CanComponentDeactivate {
          ........
          canDeactivate() : Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
            if ( !this.changesSaved ) {
              return confirm("Do you want to leave?");
            } else {
              return true;
            }
          }
        }
      </pre>
      <p>
        We can also pass static data with route without using query params or some other means. For example we may have a 
        generic error component and wwe want to pass error message with the route. We can do that as follows,
      </p>
      <p>In app-routing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'not-found', component: ErrorComponent, data: {message: 'Page Not Found'}},
          { path: '**', redirectTo: '/not-found'}  
        ]
      </pre>
      <p>In error.component.ts file,</p>
      <pre>
        errorMessage: string;

        constructor(private route: ActivatedRoute){}

        ngOnInit() {
          this.route.data.subscribe(
            (data: Data) => {
              this.errorMessage = data['message'];
            }
          );
        }
      </pre>
      <p>
        Lets see how we can also pass dynamic data with a route. For example, inside student details component, we may want to
        show dynamic data (may be loaded from server) for individual student. Yes, we can do that inside the ngOninit function
        but we can also do the same before loading the route. For that we need a resolver (a service) which will allow us to run some code
        before the route is rendered. 
      </p>
      <p>In student-resolver.service.ts file,</p>
      <pre>
        import { Resolve } from '@angular/router';

        interface Student {
          id: number;
          name: string;
        }

        export class StudentResolver implements Resolve&lt;Student&gt; {
          resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
                  Observable&lt;Student&gt; | Promise&lt;Student&gt; | Student {
            return this.someservice.getStudent(+route.params['id'])   ## for refernce, see previous example codes.
          } 
        }
      </pre>
      <p>In app-routing.module.ts file,</p>
      <pre>
        const appRoutes : Route = [
          .......
          { path: 'students', component: StudentComponent, children: [
            { path: ':id', component: StudentDetailsComponent, resolve: {sr: StudentResolver}},
            .....
          ]}
        ]
      </pre>
      <p>In student-details.component.ts file,</p>
      <pre>
        student: {id:number, name:string};

        ngOninit() {
          this.route.data.subscribe(
            (data: Data) => {
              this.student = data['sr'];
            }
          );
        }
      </pre>
      <p>
        Now here's one important thing, so far the way we have used routes works fine here on our local setup but actually, 
        If we have a route like this and we are hosting this on a real server somewhere, this might not work out of the box.
        Because there, routes, the URL is always parsed & handled by the server which hosts our application. The server 
        hosting our Angular single page application has to be configured such that in a case of a 404 error, it returns the 
        index.html file, the file starting and containing our Angular app. As all our URLs are parsed by the server first 
        (not by Angular), now if we have /students there, it will look for a /students route on our server. Now chances are 
        we don't have that route here because we only have one file there, index.html containing our Angular app and we want 
        Angular to take over and parse this route but it will never get a chance. Rather our hosting server will show 404 page. 
        Therefore we need to make sure that in such a case, our web server returns the index.html file. (More in deploy section)   
      </p>
    </div>
    </section>
    <section>
      <h2>Observable</h2>
      <p>
        It can be data sources, user input events, http requests or something triggered in the code. Between observer & observable 
        there is a stream where observable emits data. An observer (more likely the codes we write) usually handle three types of things: 
        data, error & completion of observable. 
      </p>
      <p>Observables are constructs in which we subscribe to be informed about changes in data.</p>
      <p>For example, we have used params observable in routing section.</p>
      <p>Lets build our own observable and understand it's internals.</p>
      <p>Observable is provided by a package called <span>rxjs</span>. It gives us different ways to create an observable.</p>
      <pre>
        import { interval } from 'rxjs';

        ngOnInit() {
          interval(1000).subscribe( count => {
            console.log(count);
          });
        }
      </pre>
      <p>Here 'interval' is an observable provided by rxjs which will emit incremental number every 'n' seconds defined by us.</p>
      <p>
        Here if we go to some other component, we see that the interval observable do not stop emitting data. That's because 
        observable doesnot necessarily stop just because we are not interested any more. There are certain observables that emit some 
        values and then they are done, i.e http observables, but some observables may continue emitting data. To stop that we have to
        unsubscribe the observable.
      </p>
      <pre>
        import { interval, Subscription } from 'rxjs';

        private obsSubs: Subscription;

        ngOnInit() {
          this.obsSubs = interval(1000).subscribe( count => {
            console.log(count);
          });
        }

        ngOnDestroy() {
          this.obsSubs.unsubscribe();
        }
      </pre>
      <p>So far we have only implemented an observable provided by rxjs. Now we will rebuild this interval observable by ourself.</p>
      <pre>
        import { Observable, Subscription } from 'rxjs';

        private obsSubs: Subscription;

        ngOnInit() {
          const customIntervalObservable = Observable.create(observer => {
            let count = 0;
            setInterval(()=>{
              observer.next(count);
              count++;
            },1000);
          })
          this.obsSubs = customIntervalObservable.subscribe( data => {
            console.log(data);
          });
        }

        ngOnDestroy() {
          this.obsSubs.unsubscribe();
        }
      </pre>
      <p>So we have built an observable that emits data. Lets see how we can throw error and other staffs.</p>
      <pre>
        ..............
        const customIntervalObservable = Observable.create(observer => {
          let count = 0;
          setInterval(()=>{
            observer.next(count);
            if (count > 10) {
              observer.error(new Error("Greater than 10!"));
            }
            count++;
          },1000);
        })

        this.obsSubs = customIntervalObservable.subscribe( data => {
          console.log(data);
        }, error => {
          console.log(error.message);
        });
      </pre>
      <p>To complete an observable,</p>
      <pre>
        ......
        const customIntervalObservable = Observable.create(observer => {
          let count = 0;
          setInterval(()=>{
            observer.next(count);
            if (count == 5) {
              observer.complete();
            }
            count++;
          },1000);
        })

        this.obsSubs = customIntervalObservable.subscribe( data => {
          console.log(data);
        }, () => {
          console.log("Completed");
        });
      </pre>
      <p>
        In general observable emits data and an observer subsribes to that observable. Now we may want to filter or transform the 
        raw data provided by observable and for that we put <span>operators</span> between observable and observer. Then we subscribe 
        to the result of the operators. Rxjs has lots of operators that we can use in our code.
      </p>
      <pre>
        import { map } from 'rxjs/operators';

        ......
        this.obsSubs = customIntervalObservable.pipe(map(data => {
          return 'Round: ' + (data+1);
        })).subscribe( data => {
          console.log(data);
        }, () => {
          console.log("Completed");
        });
      </pre>
      <p>Using pipe we can add mutltiple operators (comma seperated) in the observable.</p>
      <pre>
        import { filter, map } from 'rxjs/operators';

        ......
        this.obsSubs = customIntervalObservable.pipe(filter(data => {
          return data%2==0;     ## First this operator will run which only allow even number.
        }), map(data => {
          return 'Round: ' + (data+1);  ## Then this operator will run on filtered data.
        })).subscribe( .... );
      </pre>
      <p>We have seen in service section that we can establish communication between cross-components by creating event emitter in the service, 
        then emit it inside one component and subscribe to other component. Instead of EventEmitter, we can use <span>Subject</span>, a special
        observable provided by rxjs. Instead of calling emit(), we will now call next() method. The remaining procedure is same as before. Also we 
        have to unsubscribe when the component is destroyed. Using subject is more efficient than EventEmiiter for cross component communication 
        (not suitable for internal events i.e parent child communication) and we can also use operators with it.
      </p>
      </div>
    </section>
    <section>
      <h2>Forms</h2>
      <p>Angular provides a javascript object representation of the form so that we can perform validation and send it to server.</p>
      <p>Two types: Template driven form & Reactive form.</p>
      <p>Template driven: Angular infers the form object from the dom.</p>
      <p>Reactive: Form is created programmatically and synchronized with the dom.</p>
      <p></p>
      <pre></pre>
      </div>
    </section>
    <section>
      <h2></h2>
      <p></p>
      <pre></pre>
      </div>
    </section>
  </main>
</body>
</html>